<!doctype html><html lang=en><head><title>探讨 Git 代码托管平台的若干问题 - 2019 版</title>
<meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=5,user-scalable=5" name=viewport><meta content="telephone=no" name=format-detection><meta name=description content><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><script src=/js/toc.js></script><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><link rel=stylesheet href=/scss/dark-mode.min.cb53f1bee2b8900cb4f082afbf00175d6618f281cf9a2fe8619e3b52d20b5721.css integrity="sha256-y1PxvuK4kAy08IKvvwAXXWYY8oHPmi/oYZ47UtILVyE=" media=screen><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Material+Icons"></head><body><div id=app><div class=single-column-drawer-container id=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item active" href=/posts>归档
</a><a class="a-block drawer-menu-item false" href=/categories>分类
</a><a class="a-block drawer-menu-item false" href=/tags>标签
</a><a class="a-block drawer-menu-item false" href=/about>关于
</a><a class="a-block drawer-menu-item false" href=/index.xml>RSS Feed</a><div class=toc><div class=toc-content><center>- CATALOG -</center><ul><ul><li><a href=#%e5%85%b3%e4%ba%8e-git class=nav-关于-git>关于 Git</a></li><li><a href=#%e4%b8%8d%e5%90%8c%e4%bc%b8%e7%bc%a9%e6%80%a7%e7%9a%84-git-%e4%bb%a3%e7%a0%81%e6%89%98%e7%ae%a1%e5%b9%b3%e5%8f%b0 class=nav-不同伸缩性的-git-代码托管平台>不同伸缩性的 Git 代码托管平台</a></li><ul><li><a href=#%e5%9f%ba%e4%ba%8e%e5%86%85%e7%bd%ae%e5%b7%a5%e5%85%b7%e6%90%ad%e5%bb%ba-git-%e4%bb%a3%e7%a0%81%e6%89%98%e7%ae%a1%e6%9c%8d%e5%8a%a1 class=nav-基于内置工具搭建-git-代码托管服务>基于内置工具搭建 Git 代码托管服务</a></li><li><a href=#%e5%b0%8f%e5%9e%8b%e7%9a%84-git-%e4%bb%a3%e7%a0%81%e6%89%98%e7%ae%a1%e5%b9%b3%e5%8f%b0 class=nav-小型的-git-代码托管平台>小型的 Git 代码托管平台</a></li><li><a href=#%e4%ba%91%e6%9c%8d%e5%8a%a1%e7%ba%a7%e5%88%ab%e7%9a%84-git-%e4%bb%a3%e7%a0%81%e6%89%98%e7%ae%a1%e5%b9%b3%e5%8f%b0 class=nav-云服务级别的-git-代码托管平台>云服务级别的 Git 代码托管平台</a></li></ul><li><a href=#git-%e4%bb%a3%e7%a0%81%e6%89%98%e7%ae%a1%e5%b9%b3%e5%8f%b0%e6%9c%8d%e5%8a%a1%e5%ae%9e%e7%8e%b0 class=nav-git-代码托管平台服务实现>Git 代码托管平台服务实现</a></li><li><a href=#git-%e4%bb%a3%e7%a0%81%e6%89%98%e7%ae%a1%e5%b9%b3%e5%8f%b0%e7%9a%84%e4%bc%b8%e7%bc%a9%e6%80%a7 class=nav-git-代码托管平台的伸缩性>Git 代码托管平台的伸缩性</a></li><li><a href=#git-%e4%bb%a3%e7%a0%81%e6%89%98%e7%ae%a1%e5%b9%b3%e5%8f%b0%e7%9a%84%e5%a2%9e%e5%bc%ba%e5%8a%9f%e8%83%bd class=nav-git-代码托管平台的增强功能>Git 代码托管平台的增强功能</a></li><ul><li><a href=#%e7%bc%ba%e9%99%b7%e8%bf%bd%e8%b8%aa class=nav-缺陷追踪>缺陷追踪</a></li><li><a href=#%e6%8c%81%e7%bb%ad%e9%9b%86%e6%88%90 class=nav-持续集成>持续集成</a></li><li><a href=#%e4%bf%9d%e6%8a%a4%e5%88%86%e6%94%af%e5%92%8c%e5%8f%aa%e8%af%bb%e7%9b%ae%e5%bd%95 class=nav-保护分支和只读目录>保护分支和只读目录</a></li><li><a href=#%e5%85%b6%e4%bb%96%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6%e7%b3%bb%e7%bb%9f%e6%8e%a5%e5%85%a5 class=nav-其他版本控制系统接入>其他版本控制系统接入</a></li><li><a href=#%e5%a4%a7%e6%96%87%e4%bb%b6%e5%a4%a7%e5%ad%98%e5%82%a8%e5%ba%93 class=nav-大文件大存储库>大文件大存储库</a></li><li><a href=#%e5%ae%89%e5%85%a8%e6%80%a7%e5%a2%9e%e5%bc%ba class=nav-安全性增强>安全性增强</a></li></ul><li><a href=#%e6%96%87%e4%bb%b6%e6%9c%8d%e5%8a%a1 class=nav-文件服务>文件服务</a></li><ul><li><a href=#archive class=nav-archive>Archive</a></li><li><a href=#%e9%99%84%e4%bb%b6release class=nav-附件release>附件，Release</a></li></ul><li><a href=#git-%e7%9a%84%e6%9c%aa%e6%9d%a5 class=nav-git-的未来>Git 的未来</a></li><li><a href=#%e9%81%93%e8%b7%af%e6%bc%ab%e6%bc%ab class=nav-道路漫漫>道路漫漫</a></li><li><a href=#%e6%9b%b4%e6%96%b0 class=nav-更新>更新</a></li></ul></div></div></div></div></div><transition name=fade><div id=drawer-mask v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav id=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div id=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu
</i></button>
<a id=navTitle class=navbar-brand href=https://forcemz.net/>江二十三的思考
</a><button type=button class=nav-darkmode-toggle id=darkModeToggleButton2>
<i class=material-icons id=darkModeToggleIcon2>dark_mode</i></button></div></nav><div class=single-column-header-container id=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=https://forcemz.net/><div class=single-column-header-title>江二十三的思考</div><div class=single-column-header-subtitle>Themed by Diary.</div></a></div><div id=content><div id=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only><div class=post-title>探讨 Git 代码托管平台的若干问题 - 2019 版<div class=post-meta><time itemprop=datePublished>2019-10-01 10:00
</time><i class=material-icons>folder</i>
<a href=/categories/git>git</a>
&nbsp;</div></div></div><div class=post-body-wrapper><div class=post-body v-pre><h2 id=关于-git>关于 Git</h2><p>版本控制软件种类繁多，维基百科收录的最早的版本控制系统是 1972 年贝尔实验室开发的 <a href=https://en.wikipedia.org/wiki/Source_Code_Control_System>Source Code Control System</a>。1986 年 <a href=https://en.wikipedia.org/wiki/Concurrent_Versions_System>Concurrent Versions System(CVS)</a> 诞生，CVS 曾非常流行，但今时用之寥寥无几，不过 OpenBSD 仍在使用 CVS。2000 年 CollabNet 创建了 Subversion 项目，2009年，Subversion 被 Apache 基金会接受成为顶级项目并被命名为 <a href=https://en.wikipedia.org/wiki/Apache_Subversion>Apache Subversion</a>。2005 年 <a href=https://en.wikipedia.org/wiki/Git>Linus Torvalds</a> 创建了 Git，2007 Github 诞生后，Git 随着 Github 的发展愈发流行，14 年间，Git 成为了最流行的版本控制系统，无论是 Windows 还是 Linux 或是 Android，MySQL 等等大型软件都使用 git 进行版本控制。纵观版本控制系统流行史，前有 CVS 后有 SVN，今日 Git 更风流。俱往矣，数风流人物，还看今朝，版本控制系统莫不如斯。</p><p>与 CVS/Subversion 这种集中式版本控制系统不同的是，Git 的存储库数据会被存储在本地，提交也是发生在本地，远程可以看作是本地存储库的一个镜像。而 CVS/Subversion 的提交都是在线的。这就是分布式版本控制系统的核心特征。（理解这一问题的关联在于区分工作树 <code>worktree</code> 和存储库 <code>repository</code>。）</p><p>Git 的源码托管在 <a href=https://git.kernel.org/pub/scm/git/git.git/>git.kernel.org</a> 上，Github 上也有只读镜像 <a href=https://github.com/git/git>github.com/git/git</a>。Git 主页 <a href=https://git-scm.com>https://git-scm.com</a> 的网页源码则托管在 Github 上。通常给 git 提交 PR 需要注册 <a href=https://public-inbox.org>public-inbox.org</a> 邮件列表，然后发送补丁。者通常比较麻烦，好在有微软开发者<a href=https://github.com/dscho>Johannes Schindelin</a> 使用 TypeScript 开发 <a href=https://github.com/gitgitgadget/gitgitgadget>gitgitgadget</a> ，当你在 Github 上像 <a href=https://github.com/gitgitgadget/git>gitgitgadget/git</a> 提交 PR 时，gitgitgadget 会将你的 PR 发送到 public-inbox，一旦补丁被 git 维护者接受，gitgitgadget 则会关闭那个 PR。gitgitgadget 简化了给 git 贡献代码的难度，省去了注册 Inbox 的麻烦，这年头开发者大多都有 Github 帐号。我就使用 gitgitgadget 给 git 提交了一个<a href=https://github.com/gitgitgadget/git/pull/69>补丁</a>用于支持 HTTP/2。</p><p><a href=https://github.com/dscho>Johannes Schindelin</a> 此人也是 <a href=https://github.com/git-for-windows/git>git-for-windows</a> 的维护者。
Git 的维护者则是 Google 的开发者 <a href=https://github.com/gitster>Junio C Hamano</a>。大多数 Git 开发者来自于 Google/Microsoft（包括 Github）。libgit2 的开发者主要来自 Microsoft（包括 Github）。而 JGit 的开发者则主要来自 Google。已故 JGit 的创始人 Shawn Pearce 还开发了著名的 <a href=https://www.gerritcodereview.com/>Gerrit Code Review</a>。这些开发者的无私奉献才能使我们用上这么优秀的版本控制系统，感谢他们的付出。</p><p>Git 与远程存储库之间的传输协议有 HTTP, GIT(<code>git://</code>)，SSH. 在 <a href=https://git-scm.com/book/en/v2/Git-on-the-Server-The-Protocols>《Pro Git - 2nd Edition》4.1 Git on the Server - The Protocols</a> 中有介绍。其中 HTTP 协议包括哑协议和智能协议，由于哑协议是只读协议，目前大多数代码托管平台均不再提供支持。HTTP 智能协议和 GIT 协议，SSH 协议类似，都是特定几组 客户端/服务端 git 命令之间的输入输出数据传输和交换。Git 传输协议较为简单，以智能传输协议 v1 为例，基本的 <code>fetch/push</code> 流程如下：</p><p>Git 拉取流程：</p><p><img src=https://s1.ax1x.com/2020/09/20/w7i84e.png alt="Fetch Flow"></p><p>Git 推送流程：</p><p><img src=https://s1.ax1x.com/2020/09/20/w7iaut.png alt="Push Flow"></p><p>虽然在 2018 年 5 月，git 推出了 <a href=https://opensource.googleblog.com/2018/05/introducing-git-protocol-version-2.html><code>Wire Protocol</code></a>（即 Git v2 协议），增加了 Git 协议的复杂性，但在服务器上支持 git 协议（包括 v2 协议）仍然只需要在服务器上运行 git-upload-pack/git-receive-pack。这使得开发者很容易实现对 git 协议的支持。正因为 Git 协议表征的简单，所以针对不同的用户和存储库数量规模，Git 也都比 Subversion，Mercurial 有更多的选择。</p><p>Git 使用文件快照记录文件变更，当对象存储到松散文件目录时，每一次大小不变的文件修改相当于存储库中增加特定文件的大小，Git 使用 zlib <a href=https://en.wikipedia.org/wiki/DEFLATE>deflate</a> 压缩对象，对象头包括对象类型，原始大小。基于快照的方式使得 Git 在提交代码，检出文件时都比较高效，但存储库的占用缺比较高。但运行 <code>git gc</code> 时，Git 会将松散的对象打包到 pack 文件中，这个时候会使用特定的机制存储一部分文件的 <code>OFS_DELTA</code>，这样就能节省一部分空间。</p><p>zlib（deflate） 压缩算法通常来说除了没有版权限制，无论是压缩比还是速度，CPU 使用率都不是一个最佳的选择，引用来自的 <a href=https://github.com/facebook/zstd/tree/2164a130f353e64a1e89c8e60f36cf2498ab1eea#benchmarks>https://github.com/facebook/zstd</a> 基准测试，zlib 看起来必后起之秀 <code>brotli</code>/<code>zstd</code> 差多了：</p><table><thead><tr><th>Compressor name</th><th>Ratio</th><th>Compression</th><th>Decompress.</th></tr></thead><tbody><tr><td>zstd 1.4.0 -1</td><td>2.884</td><td>530 MB/s</td><td>1360 MB/s</td></tr><tr><td><strong>zlib 1.2.11 -1</strong></td><td>2.743</td><td>110 MB/s</td><td>440 MB/s</td></tr><tr><td>brotli 1.0.7 -0</td><td>2.701</td><td>430 MB/s</td><td>470 MB/s</td></tr><tr><td>quicklz 1.5.0 -1</td><td>2.238</td><td>600 MB/s</td><td>800 MB/s</td></tr><tr><td>lzo1x 2.09 -1</td><td>2.106</td><td>680 MB/s</td><td>950 MB/s</td></tr><tr><td>lz4 1.8.3</td><td>2.101</td><td>800 MB/s</td><td>4220 MB/s</td></tr><tr><td>snappy 1.1.4</td><td>2.073</td><td>580 MB/s</td><td>2020 MB/s</td></tr><tr><td>lzf 3.6 -1</td><td>2.077</td><td>440 MB/s</td><td>930 MB/s</td></tr></tbody></table><p>当开发者要将 git 集成到其他软件或者系统中时，可以通过命令行调用 git 命令捕获输出，也可以使用 libgit2/JGit 等库。</p><p>libgit2 最初是由 Shawn Pearce 创建了<a href=https://github.com/libgit2/libgit2/tree/c15648cbd059b92c177586ab1701a167222c7681>初始 commit</a>。目前主要维护者来自微软。libgit2 提供一些基础的 API，功能基本上是完整的，除了一部分实现性能没有 git 那么好，其他方面令人满意，并且有多种语言绑定，包括 C++/D/Golang/Ruby/.NET/Node.js/Perl/Perl6/Ruby/Rust 等等。Gitee 原生钩子就使用了 libgit2，Gitee-gitlab 项目使用了 rugged。</p><p>JGit 也是有 Shawn Pearce 创建的，目前属于 Eclipse 基金会，运行在 JVM 上，国内腾讯的工峰的 TGit 也是使用的 JGit。</p><p>在 <a href=https://git.github.io/rev_news/2019/02/27/edition-48/>Git Rev News 第48期</a>，编辑推荐了 <a href=https://github.com/src-d/gitbase>gitbase</a> 通过 SQL 的方式查询 git 存储库，这个工具基于 <a href=https://github.com/src-d/go-git>src-d/go-git</a>，go-git 是纯 Golang 实现的，如果基于 Golang 的项目需要简单的读写存储库，可以使用 go-git。与 libgit2 的 Golang 绑定 git2go 相比，不需要使用 CGO。</p><p>当然还有一些其他的 git 实现，大多是实验性的，不建议用于生产环境，比如基于 Rust 的 <a href=https://github.com/chrisdickinson/git-rs>git-rs</a>。</p><h2 id=不同伸缩性的-git-代码托管平台>不同伸缩性的 Git 代码托管平台</h2><h3 id=基于内置工具搭建-git-代码托管服务>基于内置工具搭建 Git 代码托管服务</h3><p>Git 最初由 Linus Torvalds 开发用来取代 BitKeeper 作为 Linux 内核源码的版本控制工具，所以 Git 一直和 Linux 内核源码托管在同一个服务器上。官方地址是：<a href=https://git.kernel.org/>https://git.kernel.org/</a>。在 git.kernel.org 上，Git 代码托管功能是由 git 内置的工具实现的。用户使用 HTTPS 协议访问 <a href=https://git.kernel.org/>https://git.kernel.org/</a> 时，Nginx 会以 CGI 的方式将浏览器的请求转发到 <a href=https://git.wiki.kernel.org/index.php/Gitweb>GitWeb</a>。GitWeb 是一个使用 Perl 编写的 CGI 程序，为用户提供简单的 git 在线交互图形界面。GitWeb 的源码地址可以在 <a href=https://github.com/git/git/blob/master/gitweb/gitweb.perl>Github Git 镜像</a> 中查看。GitWeb 界面比较不够精美，相比于 Github 这样的代码托管平台，功能寥寥无几。当用户需要使用 HTTP/HTTPS 协议拉取推送源码时，Nginx 会以 CGI的方式将请求转发给 <a href=https://git-scm.com/docs/git-http-backend>git-http-backend</a> 处理。git-http-backend 是 <strong>Git Over HTTP</strong> 的服务端实现。当用户 GIT 协议 (<code>git://</code>) 在 git.kernel.org 上拉取源码是，请求会被 <a href=https://git-scm.com/docs/git-daemon>git-daemon</a> 处理。<a href=https://git-scm.com/docs/git-daemon>git-daemon</a> 默默的监听 9418 端口，静静的等待 git 客户端的访问。</p><p>使用 Git 内置的 GitWeb/git-http-backend/git-daemon，我们能够搭建一个简易的 Git 代码托管服务器，但这里没有 SSH 协议支持。而实现 SSH 协议支持也非常简单，只需要在服务器上运行 <code>sshd</code> (OpenSSH)，并允许命令 <code>git-upload-pack/git-receive-pack/git-upload-archive</code> 命令的运行，对于 SSH 协议的验证，我们则可以使用 <code>authorized_keys</code> 机制，将需要允许的用户的 SSH 公钥添加到 <code>authorized_keys</code> 文件。</p><p>这种方案通常使用 <a href=https://gitolite.com/gitolite/>Gitolite</a> 增强访问控制，Gitolite 主要使用 Perl 编写，这和 GitWeb 一致，ssh 的验证是将 <a href=https://github.com/sitaramc/gitolite/blob/master/src/gitolite-shell>gitolite-shell</a> 添加到 <code>~/.ssh/authorized_keys</code> 中被 sshd 调用实现的。git.kernenl.org 正是使用 Gitolite 实现 Git Over SSH 访问控制。</p><p><a href=https://git.kernel.org/>https://git.kernel.org/</a> 网站托管了 Linux 内核源码，驱动，文档等大概有 1000 多个存储库，较大的存储库比如 Linux 内核源码磁盘占用大概是 2GB，因此在理想情况下，一块 2TB 磁盘的服务器便可支撑 <a href=https://git.kernel.org/>https://git.kernel.org/</a> 这个网站的运行（实际情况则并不是如此，由于 Linux 内核的流行，git.kernel.org 的请求将比较多，对硬件的需求将更高一点）。基于 Git 内置功能搭建的代码托管服务，麻雀虽小五脏俱全，不过回过头来说，这样的代码托管服务功能有限，可伸缩性和扩展性不佳。</p><h3 id=小型的-git-代码托管平台>小型的 Git 代码托管平台</h3><p>当用户需要搭建一个几人到几十几百人规模的 Git 代码托管服务，通常有非常多的选择，下面是几个目前仍然比较活跃的小型 Git 代码托管平台。</p><table><thead><tr><th>名称</th><th>平台</th><th>语言</th><th>技术概述</th></tr></thead><tbody><tr><td><a href=https://github.com/jakubgarfield/Bonobo-Git-Server>Bonobo Git Server</a></td><td>Windows Only</td><td>C#</td><td>基于 .Net Famework 4.6（迁移到 .Net Core 的建议在 2017 年便被提出，但截至目前仍为迁移到 .Net Core）。使用 <a href=https://github.com/libgit2/libgit2sharp/>LibGit2Sharp</a> 操作存储库，但版本较老，不支持 SSH 协议访问。</td></tr><tr><td><a href=https://github.com/gogs/gogs>Gogs</a></td><td>Cross Platform</td><td>Golang</td><td>基于 Golang 编写，Web 读写 Git 存储库由 <a href=https://github.com/gogs/git-module>git-module</a> 封装 Git 命令实现，SSH 由 Golang <a href=https://github.com/golang/crypto/tree/master/ssh>crypto/ssh</a> 提供，支持多种数据库，是一个极简的代码托管平台，可以在 Raspberry Pi 上运行</td></tr><tr><td><a href=https://github.com/go-gitea/gitea>Gitea</a></td><td>Cross Platform</td><td>Golang</td><td>是 Gogs 的开源分叉，Web 读写 Git 存储库使用了 <a href=https://github.com/src-d/go-git>src-d/go-git</a>，使用 <a href=https://github.com/gliderlabs/ssh>gliderlabs/ssh</a> 提供 SSH 接入功能，支持多种数据库，可以在 Raspberry Pi 上运行。</td></tr><tr><td><a href=https://github.com/gitbucket/gitbucket>GitBucket</a></td><td>Cross Platform</td><td>Scala/Java</td><td>使用 <a href=https://github.com/apache/mina-sshd>Apache Mina SSHD</a> 实现 SSH 功能。Mina SSHD 还专门针对 JGit 实现了一个 <a href=https://github.com/apache/mina-sshd/tree/master/sshd-git>sshd-git</a> 模块，但 GitBucket 是直接使用 JGit 的 <a href=https://github.com/eclipse/jgit/blob/master/org.eclipse.jgit/src/org/eclipse/jgit/transport><code>transport</code></a> 相关类。Eclipse JGit 主要由 Google 开发者参与贡献。</td></tr></tbody></table><p>除了上述定位为代码托管平台的服务，还有像 <a href=https://www.phacility.com/>Phabricator</a> 这样的 Web 软件也提供 Git 代码托管功能，但 Phabricator 的重点更多是缺陷追踪，代码审核。LLVM <a href=https://reviews.llvm.org/>https://reviews.llvm.org/</a> 和 libssh <a href=https://bugs.libssh.org/>https://bugs.libssh.org/</a> 就是基于 Phabricator。</p><h3 id=云服务级别的-git-代码托管平台>云服务级别的 Git 代码托管平台</h3><p>随着用户规模和存储库规模的增长，达到一定级别后，上述代码托管平台往往变得力不从心，而下面的代码托管平台却深耕于此，能够支撑巨大规模的用户量和存储库数量。</p><p><a href=https://github.com>Github</a> 是全球最大的代码托管平台，目前 Github <a href=https://github.com/about>官方数据</a>显示注册用户数量为 4000万，项目数量为 1亿。Github 网站主要的技术是 <a href=https://rubyonrails.org/>Ruby on Rails</a> 内部进程名为 <code>github-unicorn</code>，最近他们将其升级到了 <a href=https://github.blog/2019-09-09-running-github-on-rails-6-0/>Rails 6.0</a>。Github 使用 Spokes 负责文件系统上存储库的复制，同步和备份。Github 之前使用 libssh 开发 Git SSH 服务器，目前的 SSH 服务器的标识为 <code>babeld-*</code>，但不确定 babeld 是否依然基于 libssh。Git 验证服务为 <code>github-gitauth</code>。Github 的大多数服务都是闭源的，因此分析 Github 的技术内幕通常是 Github 官方的一些技术博客， 当然也可以分析 <code>Github Enterprise</code> 去窥测 Github 内幕。</p><p>关于 Github Spokes 的大致原理可以阅读 <a href=https://githubengineering.com/introducing-dgit/>Introducing DGit</a> 和 <a href=https://github.blog/2016-09-07-building-resilience-in-spokes/>Building resilience in Spokes</a>。</p><p>在开发 <a href=https://gitlab.com/gitlab-org/gitaly>Gitaly</a> 之后， <a href=https://gitlab.com>Gitlab</a> 摆脱了 NFS 的禁锢，在平台的伸缩性方面得到了巨大的提升。要知道 Gitlab 使用 Gitaly 的原因可以阅读 <a href=https://about.gitlab.com/2018/09/12/the-road-to-gitaly-1-0/>The road to Gitaly v1.0</a>。Gitaly 使用 RPC 将存储服务器上的 git 命令包转成前端服务机器上的 git 命令，并为 gitlab 服务提供存储库的读写。 Gitlab 的 SSH 功能仍然由 OpenSSH 提供，而一些静态资源，文件下载，附件等功能则由 Golang 编写的 <a href=https://gitlab.com/gitlab-org/gitlab-workhorse>gitlab-workhorse</a> 实现，gitlab-workhorse 需要与 Gitaly 通信。</p><p><a href=https://bitbucket.org>Bitbucket</a> 是 <a href=https://www.atlassian.com>Atlassian</a> 开发的代码托管平台，与 Github/Gitlab 不同，Bitbucket 还提供了原生 Mercurial 支持，不过最近，Bitbucket 宣布要逐步关闭 Mercurial 的支持。Atlassian 还开发了 Jira/Sourcetree 这样著名的软件，Bitbucket 源码没有开发，推测主要使用 Java 技术栈（这个从一次 Bitbucket VFSForGit 安装包分析可得）。</p><p><a href=https://gitee.com>Gitee</a> 是目前国内最大的代码托管平台之一，早在 2015 年便开始了分布式改造，并编写了一系列服务实现分布式架构，编写了 Nginx 路由模块实现动态路由，基于 libssh 开发了 Basalt v1 SSH 服务器，基于 Golang 开发了 Basalt v2 SSH 服务器，还开发了 git-srv 智能服务后端，brzox Git HTTP/Archive 服务。以及 git-diamond git 协议内部传输服务等等。Gitee 最初代码基于 Gitlab，几年之间已经与 Gitlab 有了很大的差异，现在 Gitee 已经逐步将一些功能从 gitlab 中剥离，实现云平台的微服务，比如目前的 git/svn/hook 验证服务是基于 Golang 编写的 banjo。Gitee 需要以有限的硬件实现更多的用户接入，所以在服务的设计上更倾向于提供资源使用率，对一些比较容易造成计算资源紧张的服务进行降级。</p><h2 id=git-代码托管平台服务实现>Git 代码托管平台服务实现</h2><p>Git 代码托管平台的基本服务应该包括浏览器接入支持和 git 客户端接入支持，前者需要平台开发网页提供若干服务供用户访问。后者需要支持 git 客户端推拉代码。通过网站访问存储库意味着 HTTP 服务需要通过一定的途径读写存储库，在 GitWeb 中，这通常使用 git 命令实现，比如使用 <code>git tree</code> 查看 <code>tree</code>，使用 <code>git archive</code> 打包文件等等。在 Gogs 中，使用的 <a href=https://github.com/gogs/git-module>git-module</a> 同样使用了命令读写存储库。而 Gogs 的分叉 Gitea 则使用的是 <a href=https://github.com/src-d/go-git>src-d/go-git</a> 读写存储库。实际上我们常常有那种感觉，使用命令行可能会比直接调用 API 慢，并且错误难以处理，这通常是对的。比如我们查看 <code>HEAD</code> 对应的引用，使用命令我们可以运行 <code>git symbolic-ref HEAD</code>，运行这个命令我们需要 fork 出一个进程，fork 成功后马上在子进程中执行 exec git symbolic-ref，为了读取 git symbolic-ref 的输出，我们还需要创建几对 Pipe，并检测 git symbolic-ref 的退出值。而使用 libgit2 API 我们只需要调用 <code>git_repository_open</code>,<code>git_reference_open</code>,<code>git_reference_symbolic_target</code> 即可拿到对应的引用。而对于服务程序而言，fork-exec 的代价可能不小。当然你也可以直接使用 <code>open("/path/to/.git/HEAD")</code> 然后解析 HEAD 对应的引用。GitBucket 使用 JGit 读写存储库，Gitlab 曾经历了 Grit (Grit 部分命令部分 Git 纯 Ruby 实现，Github 曾经使用)。后来的 Rugged，到现在 Gitaly 的纯命令 + Ruby Repository（Gitlab 现在的架构我对其保留意见，至少 IO 复制将增加多次）。Github 目前使用 Rugged 读写存储库，当然一些更多的细节因为没有源码不得而知。Gitee 目前使用 Rugged，但一部分 libgit2 实现不佳的则直接采用 git 命令实现。</p><p>实现 Git Over HTTP，Gitlab 最初采用了 Grack, 运行在 <code>unicorn</code> 中的 Grack 并发有限且容易影响 Web 访问（即 Git 请求较多时，Web 拒绝服务），而基于 Golang 开发的 Gogs，Gitea 使用 Golang 原生 HTTP 库编写 Git HTTP Server 功能，这要比 Grack 好要好很多，Golang HTTP 模型能够支撑更多的并发。目前 Gitee 的 Git HTTP Server Brzox 也是使用 Golang 编写。</p><p>实现 Git Over SSH，Gitlab 目前依然使用的是 OpenSSH，而不像 Github/BitBucket/Gitee 直接编写 SSH 服务器，直接编写 SSH 服务器可以禁用 SSH 登录，自定义错误消息，简化验证流程，减少数据拷贝。Github 早先是基于 libssh 编写的 SSH Server, 目前不得而知。BitBucket 技术上偏向 Java, 则有可能使用 Apache Mina SSHD, GitBucket 使用 Apache Mina SSHD + JGit 实现 Git Over SSH 功能。而 Gogs/Gitea 在虽然使用 Golang crypto/ssh 编写了 SSH 服务，但在实现时仍然使用了中间命令，这就导致数据拷贝次数的增加，观测 Gogs/Gitea 的各种服务实现，这可能是设计不足的妥协吧。</p><p>实现 Git Over TCP （git:// 协议）也非常简单，但 Git 协议并不提供验证机制，Git 代码托管平台提不提供 Git 协议支持也无关紧要，但 Git 协议无需加密，协议简单，作为平台内部传输服务倒是可以，目前 Gitee 使用 C++ Asio 编写 git-diamond 支持内部同步，企业存储库备份等功能。</p><h2 id=git-代码托管平台的伸缩性>Git 代码托管平台的伸缩性</h2><p>伸缩性是 Git 代码托管能否支撑成千上万用户/存储库的重要指标。像 Gogs/Gitea 这样的代码托管系统尽量认为自身运行在单一服务器上，因此这类 Git 代码托管平台伸缩性非常有限，当然如果使用 NFS/Ceph 这类分布式文件系统能够在单一服务器上支持更多的存储库，但 NFS/Ceph 这种分布式系统的做为 Git 代码托管系统的存储层，除了分布式文件系统带来的性能下降，还会带来内网带宽过高等更多的问题。</p><p>我们以使用 NFS 挂载实现伸缩性的平台和 Gitee 分布式模型 git 请求 对比，I/O 细节简化如下：</p><p>NFS I/O 细节：</p><p><img src=https://s1.ax1x.com/2020/09/20/w7idDP.png alt=NFS></p><p>Gitee Basalt I/O 细节：</p><p><img src=https://s1.ax1x.com/2020/09/20/w7iDUS.png alt=Basalt></p><p>计算机是质朴的，流程的增加往往需要更多的计算资源，与 Basalt-GitSrv 相比，NFS 的 I/O 拷贝要多一些，排除 Git 协议影响我们可能会认为 Basalt 的机制要比 NFS 更节省 I/O。如果考虑到 Git 协议的影响，我们应该确信如此，git 推送或者拉取都需要耗费大量的 CPU 计算资源，而在 NFS 模型中，计算全部都是发生在前端服务器，当请求数量较多时，前端服务器则容易出现 CPU 竞争的局面，这将非常影响服务器性能，另外，对于 NFS 这样的文件系统，读写 Git 松散对象都是不得力的。另外，由于 NFS 的缓存机制，负载较高时会出现 <code>master.lock</code> 这样的锁定情况，导致用户使用异常。而对于 Basalt，git 则是在存储服务器上直接操作存储库，打包压缩，解压等对 CPU 需求较高的活动也在存储服务器上，这样意味着，CPU 计算被摊薄到存储服务器上了，另外 basalt-gitsrv 中间传输的是打包后的数据，这与 NFS 读写多个文件相比，网络数据量实际上是下降的。</p><p>Gitee 作为国内最早的 Git 代码托管平台之一，最开始使用 NFS 实现伸缩性，随着用户规模增长很快出现了上述所有 NFS 容易遇到的问题，后来尝试切换到 Ceph，git 松散对象给其致命一击，上线便宣告失败，出现了严重的宕机事故，数据被毁，只能从备份恢复。后来迁移到分布式架构后基本稳定运行至今（这种方案基本上增加机器即可，前端负载高加前端，存储满了加存储）。</p><p>Github 目前有大约 1亿个项目，我们假设 Github 上存储库大小平均为 10MB，目前 Github 存储库使用三副本机制，大概需要的磁盘容量为 2861 TB，按照硬盘出厂的规则（1000GB=1TB）,则是需要最小 3PB。这么大的磁盘容量并不是一个标准服务器能够提供的，按照目前企业级硬盘容量较大的每个 16TB, 则需要硬盘大概 188 块。你能想象到这样大的规模能够简单的运行在分布式文件系统上吗？目前的技术基本上不太现实。</p><p>实现 Git 代码托管平台的可伸缩性重要的是实现资源的分片，最开始 Gitee 分布式时使用的是基于用户（namespace）的资源分片，也就是存储库所在的机器与 namespace 所属的机器像匹配，这实际上是一种先入为主的设计，在使用 NFS 挂载的时代，Gitee 的存储库就是按照 namespace 的前两个字母分片存储到不同服务器上，挂载到前端服务器上。因此，基于 namespace 的分片带来了一些问题，比如用户转移存储库可能需要跨机器，fork 存储库也可能需要跨机器，这就无法实现高效的轻量级 fork 功能。从去年开始迁移到基于存储库的分片，基于存储库分片基本上可以解决这些问题，但由于历史原因，轻量级 fork 等功能道阻且长。</p><p>资源的分片和请求的路由相伴而生，将存储库存储到不同服务器上后，则需要在这些服务器上实现对应的服务支持前端的请求，而前端也需要实现特定的路由机制，关于 Gitee 的路由机制架构，可以参考相关演讲或者博客。Gitee 存储服务器上使用了 git-srv 作为 Git 传输协议后端服务，而 Github 则使用了 DGit/Spokes，Gitlab 使用了 Gitaly。不同平台的技术各有侧重，比如 Gitlab Gitaly 侧重兼容旧的 OpenSSH，而 Gitee 的 Basalt-GitSrv 针对实际情况优化，与 Gitaly 相比要少一次 I/O 拷贝。 Gitee 目前不足之处是存没有完全剥离 Web(基于早期 Gitlab 发展而来)，而 Gitaly 也有 Ruby 代码实现存储库读写（这块代码用 Golang 封装 I/O 多了一次拷贝）。与 Gitee 类似，Gitea 还有另一种方案，即将 Gitea 部署到多个服务器上共用 DB 支持分片，比如 <a href=https://gitea.com>gitea.com</a> 便是这样的平台，但 gitea.com 似乎并不支持 SSH，因此并不能算有效的分片。</p><p>前端服务器的扩展性实际上要比存储服务器好，前端服务器的迁移一般不需要像存储服务器那样转移存储库，服务也一般更简单。</p><p>存储库分片之后还是无法避免特定存储库请求过多的问题，Github 的解决方案是使用三副本读写分离的 Spokes 机制，这一方案最多能够提供 3倍于单一服务器的并发读取能力，但不支持并发写入存储库。三副本机制需要解决分布式系统常见的一致性问题，引入并发写入可能会带来更多的数据冲突，破坏一致性，因此 Github 完全禁止并发写入存储库副本（即同时有不同的写存储库请求）。Gitlab 没有实现这样的技术，BitBucket 则没有披露相关资讯，Gitee 受限与硬件限制和开发资源限制，也没有实施。</p><p>github-dfs：</p><p><img src=https://s1.ax1x.com/2020/09/20/w7i63j.png alt=DGIT></p><p>除了存储库的分片，代码托管平台还需要考虑数据库 SQL/NoSQL 能否支撑大规模并发，数据库的分布式集群是一个比较成熟的方案，而 Redis 最新的版本也支持集群，因此数据库的伸缩性一般不会存在太大问题，增加机器搭建集群即可。选择关系性数据库时还需要考虑许可证，数据库自身的功能等，比如 Gitlab 目前已经放弃对 MySQL 的支持，而是选择了 PostgreSQL，不过 Gitlab 的选择对于其他代码托管平台来说，也只能算作<strong>仅作参考</strong>。MariaDB 是 MySQL 的分支版本，随着 MySQL 被 Oracle 收购，开源社区渐渐丧失了对 MySQL 的兴趣，虽然 MySQL 8.0 发布已经很久，但采用 MySQL 8.0 的发行版本寥寥无几，很多还停留在 MySQL 5.X，有些发行版还使用 <a href=https://github.com/MariaDB/mariadb-connector-c>mariadb-connector-c</a> 替代 <code>libmysqlclient</code> 作为数据库连接器，使用 MySQL 的平台很容易迁移到 MariaDB 而不用修改客户端数据库连接代码 ，MariaDB 支持线程池，而 MySQL 仅在企业版中支持线程池。一些 MariaDB 与 MySQL 的对比这里不赘述了。Gogs/Gitea 还支持使用 SQLite，但其使用 SQLite 时，基本上是放弃了伸缩性，不过目前有一个使用 Raft+libuv 实现的分布式 SQLite <a href=https://github.com/canonical/dqlite>canonical/dqlite</a>，可以尝试一下。Redis 一般可以作为 Web 缓存或者任务队列的中间件，目前 Redis 虽然支持集群，但就单机 Redis 而言，由于它是单线程的服务，在将内存数据持久化到磁盘是还是可能出现超时，并且单线程服务性能终究有限，在 Github 上，<a href=https://github.com/JohnSully/KeyDB>KeyDB</a> 是官方 Redis 的另一个选择，KeyDB 是 Redis 的分支，完全兼容 Redis 协议，KeyDB 支持多线程，有更好的内存效率和高吞吐量。</p><h2 id=git-代码托管平台的增强功能>Git 代码托管平台的增强功能</h2><p>除了支持用户通过 Git 协议或者通过网页方式读写远程存储库，代码托管平台一般还需要提供一些与开发相关的功能增强用户体验，这些功能在不同平台之间的对比时显得非常重要。</p><h3 id=缺陷追踪>缺陷追踪</h3><p><a href=https://www.sqlite.org>SQLite3</a> 使用 2007 年诞生的版本控制系统 <a href=https://fossil-scm.org>Fossil</a> 托管其源码，与前辈 Git 相比，它集成了 Bug 追踪，Wiki，论坛和技术报告。而对于 Git 来说，这些则需要 Git 代码托管平台自己实现，当然现在无论是 Github/Gitee/Gitlab/BitBucket 还是 Gogs/Gitea 都提供了 <code>Issues</code>这样的机制方便开发者第一时间报告软件缺陷或者提出功能建议。<code>Issues</code> 这样的功能实现主要在于让用户参与其中，也就是用的人多了，才有人气。而 Github 的 <code>Issues</code> 相比其他平台是最活跃的。另外 Github 还提供依赖警报功能（详情可以阅读 <a href=https://github.blog/2017-11-16-introducing-security-alerts-on-github/>Introducing security alerts on GitHub</a>），另外 Github 还收购了 Semmle 代码分析用于连续漏洞检测 (参考：<a href=https://github.blog/2019-09-18-securing-software-together/>Securing software, together</a>），这也是其他 Git 代码托管平台可以借鉴的功能。</p><h3 id=持续集成>持续集成</h3><p>在微软收购 Github之后，Github 有了更充足的财力在给用户提供持续集成功能，今年以来 Github 推出了 <a href=https://github.com/features/package-registry>GitHub Package Registry</a> 和 <a href=https://github.com/features/actions>Github Actions</a> （相关文章：<a href=https://github.blog/2019-08-08-github-actions-now-supports-ci-cd/>GitHub Actions now supports CI/CD, free for public repositories</a>，<a href=https://github.blog/2019-05-10-introducing-github-package-registry/>Introducing GitHub Package Registry</a>），在推出 Github Actions 之前，开发者在 Github 上大多是通过第三方软件实现 CI/CD 功能，比如我的 <a href=https://github.com/M2Team/Privexec>M2Team/Privexec</a> 就使用 Appveroy。Windows Terminal 则使用 Azure Pipeline。平台的生态繁荣得益于第三方的支持，而对于其他平台，这些 CI/CD 支持就没有这么大的力度了，这也促使其他代码托管平台的 API 趋向 Github 化，WebHook 也逐步趋同，Github 形成了事实上的标准。比如 Gitee 的 APIv5 就保持了对 Github 的兼容。</p><p><strong>2020-09-20 更新</strong> Github 的 Actions 已经是一个成熟的持续集成流水线，目前 <a href=https://github.com/M2Team/Privexec>M2Team/Privexec</a> 已经迁移到 Github Actions，另外我开发的 Windows 包管理工具 <a href=https://github.com/baulk/baulk>baulk</a> 也使用了 Github Actions。通过编写 Github Actions 插件，可以完成编译测试部署等工作，不能认为其是单一的持续集成工具。</p><h3 id=保护分支和只读目录>保护分支和只读目录</h3><p>Gitee 很早就实现了类似 SVN 的保护分支功能，而 Github 目前也同样支持保护分支。实现保护分支的途径很很多条，通常通过服务端 Git 钩子实现，我曾写过 <a href=https://forcemz.net/git/2019/07/31/GNKServerSide/>《服务端 Git 钩子的妙用》</a> 介绍了如何通过钩子实现保护分支功能。</p><p>只读目录功能同样可以通过钩子实现，如果不通过钩子，而是在 git 命令中实现，则要面临修改 git 源码，需要投入大量人力维护的情况。《服务端 Git 钩子的妙用》和 <a href=https://forcemz.net/git/2019/04/01/ImplementGitDirPermissionControl/>《实现 Git 目录权限控制》</a>对实现目录权限控制有详细介绍。</p><h3 id=其他版本控制系统接入>其他版本控制系统接入</h3><p>将使用其他版本控制系统的存储库转为 Git 非常简单，git 自身提供了 <code>git svn</code> 命令，可以将远程 svn 存储库一个个版本递归的转变为 Git 存储库，详细的操作可以参考 <a href=https://git-scm.com/book/en/v2/Git-and-Other-Systems-Migrating-to-Git>《Pro Git 2nd Edition》9.2 Git and Other Systems - Migrating to Git</a>，这种方案的缺点比较是比较耗时，Gitee 开发者曾经帮助国内某汽车制造企业将 Subversion 存储库迁移到 Git，一开始使用 <code>git svn</code>，发现耗费时间太长，于是我找到了一个开源工具： <a href=https://github.com/satori/git-svn-fast-import>git-svn-fast-import</a>，将其编译好并修复特定 BUG 交给相关同事，后来该企业的迁移工作顺利完成。这个工具直接解析存储库将其转换为 git 存储库，省去了网络传输的消耗。</p><p>除了支持从其他版本控制系统导入外，一些代码 Git 代码托管平台也支持其他协议接入，Github/Gitee 都支持 Subversion 接入，也就是同一个存储库同时支持 git 客户端和 svn 客户端接入（像 BitBucket 支持 Mercurial 的实现实际上是单独搭建 Mercurial 存储库，不属于此类情况）。实现 Subversion 的接入几个难点，一是 Subversion 各种传输协议细节完全不同，HTTP 基于 WebDAV，而 SVN 协议又是一种自定义的 <a href=https://github.com/apache/subversion/blob/trunk/subversion/libsvn_ra_svn/protocol>ABNF 格式协议</a>，如果在考虑支持 Subversion 接入时还需要考虑选择哪种协议，两类协议都支持通常是不现实的，费时费力。二是 Subversion 自身也在不断发展，但实际上在愿意在 Git 代码托管平台使用 svn 的毕竟还是少数，实现 Subversion 接入通常是费力不讨好，投入与产出不成正比。</p><p>Github 实现的是 svn HTTP 协议，将 git 存储库的 commit 映射到 svn 的 revs。Github 的实现并不完美，由于需要通过 commit 计算 svn 版本信息，第一次通过 svn 协议访问存储库时会比较慢，如果当存储库较大时，检出还很容易失败，并且一次检出操作可能需要发送的非常多的请求，大概是所有目录所有文件数目之和。</p><p>Gitee 使用了 <a href=https://github.com/bozaro/git-as-svn>git-as-svn</a> 实现对 svn 的支持，支持的协议有 <code>svn://</code> 和 <code>svn+ssh://</code>，<code>svn+ssh://</code> 实际上是 <code>svn://</code> 协议通过 SSH 隧道传输，在 Gitee 中，当 Basalt 接收到客户端请求在远程服务器上运行 <code>svnserve -t</code> 命令，则会将请求转发到 git-as-svn。在 Gitea 开发者的贡献下，git-as-svn 增加了 <code>svnserve</code> 命令包装，即当 Gitea 接收到 <code>svn+ssh://</code> 协议请求时，则是启动包装的命令，进行一些列授权后然后在 shell 中与使用命令 <code>exec 3&lt;>/dev/tcp/localhost/3690</code> 与 git-as-svn 通信，Gitee 的设计简化了验证流程，能够支持分布式架构，Gitea 目前还不能做到。git-as-svn 的基于 Java 开发，早期，开发者似乎对 git 的理念研究不够透彻，git-as-svn 的内部实现细节变动非常大，早前的实现机制不太理想，性能不佳。在 Gitee 中，我们为了避免存储库较大时开启 svn 支持带来的性能下降，额外增加了对通过 svn 协议访问存储库的限制，目前是通过 svn 协议访问存储库时，存储库的大小限制为 400MB。</p><p>在早期，兼容其他版本控制系统可能是吸引用户的一大法宝，但随着 Git 的越来越流行，支持其他版本控制系统接入逐渐成了鸡肋，前人有言：“食之无肉，弃之可惜”，正是如此。像 Github/Gitee 这样的平台虽然支持 svn，但 svn 访问的还是极少数，而支持 svn 则需要花费一些人力物力，并且在系统架构设计时增加了复杂度。如果现在开发一个 Git 代码托管平台则没有必要支持 svn。Gitee 虽然支持 svn，但 svn 每日的请求数不足 1%，在这 1% 中，又有 50% 以上的请求是特定的用户使用定时命令发送的。</p><h3 id=大文件大存储库>大文件大存储库</h3><p>公共 Git 代码托管平台很多时候实际上是给用户提供免费服务，为了过多避免大文件大存储库占用平台资源，对其作出限制必不可少，通常是大文件限制 100MB, 存储库限制 1GB. 存储库的检测简单的遍历存储库 objects 目录即可，而大文件的检测则复杂一些。Gitee 最初使用 Grit 检测 commit 是否引入了 blob 原始大小大于限制的文件，但这种机制需要解析 Git 对象，检测容易坍塌（一是检测超时，二是检测逃逸，三是存储库体积膨胀），后开使用原生钩子，改变了检测机制，则避免了这些问题。详细情况可以阅读<a href=https://forcemz.net/git/2019/07/31/GNKServerSide/>《服务端 Git 钩子的妙用》</a>。</p><p>禁止大文件推送这只是堵，那么大文件应该如何存放呢？Github 推出了 LFS 方案，目前 LFS 功能已经被大多数平台支持，Github 将 LFS 存储到 AWS 上，而 Gitee/Gitlab/Gogs/Gitea 大多使用自建的 LFS 服务器，存储在特定服务器上。</p><p>如果一个存储库自身就已经非常大了，如何去解决用户的访问难题呢？比如 Windows 源码超过 <code>300GB</code>，如果用户克隆存储库，按照每秒 1MB/s 的速度，需要 85 小时，这在任何代码托管平台都是不太现实的，好在微软 2017 年发布了 GVFS（现在叫 <a href=https://github.com/microsoft/VFSForGit>VFSforGit</a>）,在使用 VFSforGit 获取远程存储库时，可以只获得目录结构，并在本地创建占位文件，但用户操作这些占位文件时，VFSforGit 客户端才会去请求服务器下载对应的对象，这大大改善了巨型存储库的操作体验。VFSforGit 本地涉及到的主要技术是 <a href=https://docs.microsoft.com/en-us/windows/win32/projfs/projected-file-system>ProjFS</a>，在 Windows 上，VFSforGit 会创建 <code>IO_REPARSE_TAG_PROJFS</code> 类型的 ReparsePoint（NTFS 重解析点），读写到这些重解析点时，ProjFS 驱动会转发到 VFSForGit 客户端下载相应的对象。微软很多开发者在 macOS 上开发，所以官方增加了对 macOS 的支持，而 <a href=https://github.com/github/VFSForGit>Github 的 VFSForGit fork</a> 则增加了对 Linux 的支持，不过离实用还有一些时日，Github ProjFS 实现库是 <a href=https://github.com/github/libprojfs>libprojfs</a>。</p><p>Git 代码托管平台支持 VFSforGit 客户端比较容易，目前除了 Visual Studio Online，还有 BitBucket 也增加了对 VFSforGit 的支持。我曾用 libgit2 开发了一个 <code>git-vfs-serve</code> 命令，用户访问 brzox 时，brzox 请求 git-srv，git-srv 执行 git-vfs-serve 便可以支持 VFSforGit 客户端的访问，不过并未上线。</p><h3 id=安全性增强>安全性增强</h3><p>Github 最近宣布了支持 WebAuthn: <a href=https://github.blog/2019-08-21-github-supports-webauthn-for-security-keys/>GitHub supports Web Authentication (WebAuthn) for security keys</a>，这种机制可以使用生物识别从而避免输入用户密码，随着信息技术的不断发展，一方面，安全机制不断完善，另一方面，用户面临的风险也会多样化，复杂化。代码托管平台管理了开发者的核心资产，因此在安全上绝不能掉以轻心。当然需要做的不仅仅是及时跟进新的安全机制，还需要对整个系统及时进行安全升级，淘汰旧的协议（比如 SSL3/TLS1.1），旧的加密，哈希算法（DSA，MD5/SHA1），及时采用新的协议（TLS1.3）,新的加密，哈希算法（ED25519，SHA3）等等。</p><h2 id=文件服务>文件服务</h2><p>一个优秀的 Git 代码托管平台，应该在软件的开发整个周期都给用户提供帮助，比如下载源码，软件发布。源码下载主要指 Archive 功能，软件的发布则需要平台提供 Release/附件下载功能。</p><h3 id=archive>Archive</h3><p>我们知道 git-archive 命令可以将存储库特定的 commit/branch 打包成一个 zip/tar 文件，而在 Git Over SSH（Git Over TCP） 实现中，只要我们允许 <code>git-upload-archive</code> 命令在远程服务器上运行，就打包远程服务器上的存储库的特定分支。但由于 git-upload-archive 与 git-upload-pack/git-receive-pack 存在一些不同，是的 HTTP 协议无法实现 archive 协商。提供 archive 下载则需要另辟蹊径。</p><p>我们在远程服务器上运行 git-archive 将其输出作为响应体的内容返回给 HTTP Client 便可实现 archive 下载功能，由于 archive 下载实际上是将 git tree/blob 遍历然后写入到归档文件后压缩（tar.gz/tar.bz2 &mldr;）或者是压缩后写入文件（zip），二者都非常消耗 CPU 资源，因此我们在实现 archive 下载功能的同时应该设计 archive 的缓存功能（当然缓存应该支持过期）。gitlab-workhorse 实现的 archive 下载功能便是先尝试命中缓存，如果没有缓存则调用 git 命令然后生成写入到缓存文件。Gitee 最近实现的 blaze-archive 也采用了类似的机制，但 blaze-archive 是一个独立的命令，这个命令实际上是被 git-srv 调用，brzox 与 git-srv 通信，brzox 将 archive 返回给 HTTP Client，而缓存的删除则是 blaze 负责的。</p><h3 id=附件release>附件，Release</h3><p>附件，Release 可以选择云方案，如果要将附件和 LFS 统一管理，实际上国内的阿里云，腾讯云之类的并不合适，这些平台对并不支持类似 AWS <code>x-amz-content-sha256</code> 这样的头部，而是 <code>Content-MD5</code> 因此这些云平台要支持 LFS 则要花费多一些功夫。选择国外的 AWS, Azure 则需要考虑经济，网络等问题。当然无论如何使用云平台都需要考虑经济问题。</p><p>平台自建附件，Release 功能可以使用分布式文件系统，如 FastDFS, 但 FastFDS 并不是一个好的选择，历史比较久，存储机制安全机制现在来说都不是很优秀。有个更好的选择是 <a href=https://github.com/minio/minio>Minio</a>, minio 使用 Golang 开发，支持 AWS API。许可协议是 <code>Apache 2.0</code>，商用没有阻碍，因此是用来搭建附件，Release 以及 LFS 存储服务器的不二选择。</p><h2 id=git-的未来>Git 的未来</h2><p>Git 虽然是当前最受欢迎的代码托管系统，但 Git 也面临了一些难题，一类是如何支持大文件大存储库，这些问题有 Git LFS, VFSforGit 这样的第三方解决方案，也有微软，Google 开发者参与的官方 <a href=https://git-scm.com/docs/partial-clone/en>Partial Clone</a>，部分克隆需要 Wire 协议支持，离可用还为时尚早。</p><p>2017年2月，Google 开发者宣布攻破 SHA1，这曾经给一些 git 用户带来了担忧，因为 git 使用 SHA1 计算对象 ID，但 git 使用的实际上是一种特殊的 SHA1，将对象类型对象长度以及对象内容合并在一起计算 SHA1，由于有长度校验，这使得 SHA1 的冲突可能被降低了，但无论如何，SHA1 也不再是安全的，Git 在源码中增加了 <a href=https://github.com/cr-marcstevens/sha1collisiondetection>sha1collisiondetection</a> 来避免 SHA1 冲突，并且增加了计划迁移到 SHA-256，并且将一些涉及到 Hash 的代码从单一的 SHA1 转变成 <code>object_id</code>。 关于 Hash 转换，可以查看文档 <a href=https://github.com/git/git/blob/master/Documentation/technical/hash-function-transition.txt>Git hash function transition</a>。</p><p>Git 从 SHA1 迁移到 SHA-256 困难重重，从<a href=https://github.com/git/git/commit/752414ae4310cd304f5e31649aaab2dcf307057c>首次增加文档</a>距今已经有两年时间，而 SHA-256 的实现还不见全貌。与 Hash 迁移相比，压缩算法的演进不重要更难实施，时至今日，zlib 压缩已经不再优秀，但 Git 可能还要负重前行。</p><h2 id=道路漫漫>道路漫漫</h2><p>软件开发一直是一个飞速变化的领域，而代码托管也要不断面临新的挑战，道路漫漫，吾辈不休。</p><h2 id=更新>更新</h2><ol><li>2020-03-17 由于 src-d 已经破产，目前 go-git 已经 Hard fork 到 [https://github.com/go-git/go-git]</li></ol><hr width=100% id=EOF><p style=color:#777>Last modified on 2019-10-01</p></div></div><nav class=post-pagination><a class=newer-posts href=/posts/2020/2020-01-10-talking-about-eating-pork/>Next<br>谈吃肉
</a><a class=older-posts href=/posts/2019/2019-08-07-implement-sudo-in-windows/>Previous<br>在 Windows 中实现 sudo</a></nav><div class=post-comment-wrapper></div></div></div></div></div><div id=sideContainer class=side-container><a class="a-block nav-head false" href=https://forcemz.net/><div class=nav-title>江二十三的思考</div><div class=nav-subtitle>Themed by Diary.</div></a><div class=nav-link-list><a class="a-block nav-link-item active" href=/posts>归档
</a><a class="a-block nav-link-item false" href=/categories>分类
</a><a class="a-block nav-link-item false" href=/tags>标签
</a><a class="a-block nav-link-item false" href=/about>关于
</a><a class="a-block nav-link-item false" href=/index.xml>RSS Feed</a></div><div class=nav-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://risehere.net/>Rise</a><br>Ported from <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
Copyright (c) 2009-2024 J23</div></div><div id=extraContainer class=extra-container><div class=toc-wrapper><div class=toc><div class=toc-content><center>- CATALOG -</center><ul><ul><li><a href=#%e5%85%b3%e4%ba%8e-git class=nav-关于-git>关于 Git</a></li><li><a href=#%e4%b8%8d%e5%90%8c%e4%bc%b8%e7%bc%a9%e6%80%a7%e7%9a%84-git-%e4%bb%a3%e7%a0%81%e6%89%98%e7%ae%a1%e5%b9%b3%e5%8f%b0 class=nav-不同伸缩性的-git-代码托管平台>不同伸缩性的 Git 代码托管平台</a></li><ul><li><a href=#%e5%9f%ba%e4%ba%8e%e5%86%85%e7%bd%ae%e5%b7%a5%e5%85%b7%e6%90%ad%e5%bb%ba-git-%e4%bb%a3%e7%a0%81%e6%89%98%e7%ae%a1%e6%9c%8d%e5%8a%a1 class=nav-基于内置工具搭建-git-代码托管服务>基于内置工具搭建 Git 代码托管服务</a></li><li><a href=#%e5%b0%8f%e5%9e%8b%e7%9a%84-git-%e4%bb%a3%e7%a0%81%e6%89%98%e7%ae%a1%e5%b9%b3%e5%8f%b0 class=nav-小型的-git-代码托管平台>小型的 Git 代码托管平台</a></li><li><a href=#%e4%ba%91%e6%9c%8d%e5%8a%a1%e7%ba%a7%e5%88%ab%e7%9a%84-git-%e4%bb%a3%e7%a0%81%e6%89%98%e7%ae%a1%e5%b9%b3%e5%8f%b0 class=nav-云服务级别的-git-代码托管平台>云服务级别的 Git 代码托管平台</a></li></ul><li><a href=#git-%e4%bb%a3%e7%a0%81%e6%89%98%e7%ae%a1%e5%b9%b3%e5%8f%b0%e6%9c%8d%e5%8a%a1%e5%ae%9e%e7%8e%b0 class=nav-git-代码托管平台服务实现>Git 代码托管平台服务实现</a></li><li><a href=#git-%e4%bb%a3%e7%a0%81%e6%89%98%e7%ae%a1%e5%b9%b3%e5%8f%b0%e7%9a%84%e4%bc%b8%e7%bc%a9%e6%80%a7 class=nav-git-代码托管平台的伸缩性>Git 代码托管平台的伸缩性</a></li><li><a href=#git-%e4%bb%a3%e7%a0%81%e6%89%98%e7%ae%a1%e5%b9%b3%e5%8f%b0%e7%9a%84%e5%a2%9e%e5%bc%ba%e5%8a%9f%e8%83%bd class=nav-git-代码托管平台的增强功能>Git 代码托管平台的增强功能</a></li><ul><li><a href=#%e7%bc%ba%e9%99%b7%e8%bf%bd%e8%b8%aa class=nav-缺陷追踪>缺陷追踪</a></li><li><a href=#%e6%8c%81%e7%bb%ad%e9%9b%86%e6%88%90 class=nav-持续集成>持续集成</a></li><li><a href=#%e4%bf%9d%e6%8a%a4%e5%88%86%e6%94%af%e5%92%8c%e5%8f%aa%e8%af%bb%e7%9b%ae%e5%bd%95 class=nav-保护分支和只读目录>保护分支和只读目录</a></li><li><a href=#%e5%85%b6%e4%bb%96%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6%e7%b3%bb%e7%bb%9f%e6%8e%a5%e5%85%a5 class=nav-其他版本控制系统接入>其他版本控制系统接入</a></li><li><a href=#%e5%a4%a7%e6%96%87%e4%bb%b6%e5%a4%a7%e5%ad%98%e5%82%a8%e5%ba%93 class=nav-大文件大存储库>大文件大存储库</a></li><li><a href=#%e5%ae%89%e5%85%a8%e6%80%a7%e5%a2%9e%e5%bc%ba class=nav-安全性增强>安全性增强</a></li></ul><li><a href=#%e6%96%87%e4%bb%b6%e6%9c%8d%e5%8a%a1 class=nav-文件服务>文件服务</a></li><ul><li><a href=#archive class=nav-archive>Archive</a></li><li><a href=#%e9%99%84%e4%bb%b6release class=nav-附件release>附件，Release</a></li></ul><li><a href=#git-%e7%9a%84%e6%9c%aa%e6%9d%a5 class=nav-git-的未来>Git 的未来</a></li><li><a href=#%e9%81%93%e8%b7%af%e6%bc%ab%e6%bc%ab class=nav-道路漫漫>道路漫漫</a></li><li><a href=#%e6%9b%b4%e6%96%b0 class=nav-更新>更新</a></li></ul></div></div></div><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up
</i></a><a type=button class=pagination-action id=darkModeToggleButton><span class="material-icons pagination-action-icon" id=darkModeToggleIcon>dark_mode</span></a></div></div><div id=single-column-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://risehere.net/>Rise</a><br>Ported from <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
Copyright (c) 2009-2024 J23</div></div><script src=/js/journal.js></script></body></html>