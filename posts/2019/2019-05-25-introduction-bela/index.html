<!doctype html><html lang=en><head><title>介绍 Bela</title>
<meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=5,user-scalable=5" name=viewport><meta content="telephone=no" name=format-detection><meta name=description content><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><script src=/js/toc.js></script><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><link rel=stylesheet href=/scss/dark-mode.min.cb53f1bee2b8900cb4f082afbf00175d6618f281cf9a2fe8619e3b52d20b5721.css integrity="sha256-y1PxvuK4kAy08IKvvwAXXWYY8oHPmi/oYZ47UtILVyE=" media=screen><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Material+Icons"></head><body><div id=app><div class=single-column-drawer-container id=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item active" href=/posts>归档
</a><a class="a-block drawer-menu-item false" href=/categories>分类
</a><a class="a-block drawer-menu-item false" href=/tags>标签
</a><a class="a-block drawer-menu-item false" href=/about>关于
</a><a class="a-block drawer-menu-item false" href=/index.xml>RSS Feed</a><div class=toc><div class=toc-content><center>- CATALOG -</center><ul><li><a href=#%e5%89%8d%e8%a8%80 class=nav-前言>前言</a></li><li><a href=#%e4%b8%80-bela-%e7%9a%84%e7%bc%98%e7%94%b1 class=nav-一-bela-的缘由>一. Bela 的缘由</a></li><li><a href=#%e4%ba%8c-bela-%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%8a%9f%e8%83%bd%e5%ba%93 class=nav-二-bela-字符串功能库>二. Bela 字符串功能库</a></li><ul><li><a href=#belaerror_code class=nav-belaerror_code>bela::error_code</a></li><li><a href=#stringcat class=nav-stringcat>StringCat</a></li><li><a href=#ascii class=nav-ascii>Ascii</a></li><li><a href=#%e5%85%b6%e4%bb%96%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%87%bd%e6%95%b0 class=nav-其他字符串函数>其他字符串函数</a></li><li><a href=#%e7%bc%96%e7%a0%81%e8%bd%ac%e6%8d%a2 class=nav-编码转换>编码转换</a></li><li><a href=#strformat class=nav-strformat>StrFormat</a></li></ul><li><a href=#%e4%b8%89-bela-windows-%e7%b3%bb%e7%bb%9f%e5%8a%9f%e8%83%bd%e5%ba%93 class=nav-三-bela-windows-系统功能库>三. Bela Windows 系统功能库</a></li><ul><li><a href=#belafinaly class=nav-belafinaly>bela::finaly</a></li><li><a href=#pathcat-%e8%b7%af%e5%be%84%e8%a7%84%e8%8c%83%e5%8c%96%e8%bf%9e%e6%8e%a5%e5%87%bd%e6%95%b0 class=nav-pathcat-路径规范化连接函数>PathCat 路径规范化连接函数</a></li><li><a href=#pathexists-%e5%87%bd%e6%95%b0 class=nav-pathexists-函数>PathExists 函数</a></li><li><a href=#lookuprealpath-%e5%87%bd%e6%95%b0 class=nav-lookuprealpath-函数>LookupRealPath 函数</a></li><li><a href=#lookupappexeclinktarget-%e5%87%bd%e6%95%b0 class=nav-lookupappexeclinktarget-函数>LookupAppExecLinkTarget 函数</a></li><li><a href=#executableexistsinpath-%e6%9f%a5%e6%89%be%e5%8f%af%e6%89%a7%e8%a1%8c%e6%96%87%e4%bb%b6 class=nav-executableexistsinpath-查找可执行文件>ExecutableExistsInPath 查找可执行文件</a></li><li><a href=#%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%90%88%e6%88%90%e6%8b%86%e5%88%86%e5%92%8c%e8%a7%a3%e6%9e%90 class=nav-命令行合成拆分和解析>命令行合成，拆分和解析</a></li><li><a href=#mapview class=nav-mapview>MapView</a></li><li><a href=#pesimpledetailsaze-%e8%8e%b7%e5%be%97-pe-%e7%9a%84%e7%ae%80%e5%8d%95%e4%bf%a1%e6%81%af class=nav-pesimpledetailsaze-获得-pe-的简单信息>PESimpleDetailsAze 获得 PE 的简单信息</a></li></ul><li><a href=#%e6%9c%80%e5%90%8e class=nav-最后>最后</a></li></ul></div></div></div></div></div><transition name=fade><div id=drawer-mask v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav id=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div id=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu
</i></button>
<a id=navTitle class=navbar-brand href=https://forcemz.net/>Charlie's Rethinking
</a><button type=button class=nav-darkmode-toggle id=darkModeToggleButton2>
<i class=material-icons id=darkModeToggleIcon2>dark_mode</i></button></div></nav><div class=single-column-header-container id=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=https://forcemz.net/><div class=single-column-header-title>Charlie's Rethinking</div><div class=single-column-header-subtitle>Themed by Diary.</div></a></div><div id=content><div id=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only><div class=post-title>介绍 Bela<div class=post-meta><time itemprop=datePublished>2019-05-25 10:00
</time><i class=material-icons>folder</i>
<a href=/categories/cxx>cxx</a>
&nbsp;</div></div></div><div class=post-body-wrapper><div class=post-body v-pre><h1 id=前言>前言</h1><p>在前面，我曾经写过一篇文章 <a href=https://forcemz.net/cxx/2019/04/29/StringFormattingTalk/>《字符串格式化漫谈》</a> 文章最后提到了 <a href=https://github.com/fcharlie/bela><code>Bela</code></a> 里面实现了一个类型安全的 <code>bela::StrFormat</code>，实际上 <code>bela</code> 还有很多有趣的功能，本文也就是说一说 Bela 有哪些有趣功能和故事。</p><h1 id=一-bela-的缘由>一. Bela 的缘由</h1><p>之前，我开发了几个开源软件，如 Windows 系统以指定权限启动进程的 <a href=https://github.com/M2Team/Privexec>Privexec</a>，Clang Windows 操作系统上自动化构建依赖管理工具 <a href=https://github.com/fstudio/clangbuilder>Clangbuilder</a>，还有 PE 分析工具 <a href=https://github.com/fcharlie/PEAnalyzer>PEAnalyzer</a>，文件分析工具 <a href=https://github.com/fcharlie/Planck>Planck</a> 等等。在编写这些工具时要重复编写一些代码，毕竟大家都知道 C++ STL 有时候并不能称心如意。在 <a href=https://github.com/abseil/abseil-cpp>Google Abseil</a> 开源后，我借鉴了这个项目的一些代码重新造了一些 <code>wchar_t</code> 版本的轮子，后来把这些代码单独抽离出来，进一步改进，也就成了现在的 <code>Bela</code>。不直接用 <code>Absl</code> 的原因很简单，它不支持 <code>wchar_t</code>。格式化字符串不使用 <code>fmtlib</code> 的原因也很简单，不喜欢异常，它的代码库也比较大。叫 <code>bela ['bələ]</code> 的原因依然很简单，简短易读易拼写。</p><p>Bela 的字符串函数基本基于 <code>Abseil</code>，<code>Unicode</code> 转换基于 LLVM 的 <code>ConvertUTF.cpp</code>，最初 <code>ConvertUTF</code> 的版权属于 <strong>Unicode.org</strong> , <code>charconv</code> 基于 <code>Visual C++ STL</code>，<code>EscapeArgv</code> 借鉴了 Golang 源码，<code>endian.hpp</code>，<code>tokenziecmdline.hpp</code> 借鉴了 <code>LLVM Support Library</code> 等等。</p><h1 id=二-bela-字符串功能库>二. Bela 字符串功能库</h1><h2 id=belaerror_code>bela::error_code</h2><p><code>bela::error_code</code> 位于 <code>&lt;bela/base.hpp></code> 类似 <code>std::error_code</code>，其主要目的是简化 Windows API 错误信息的格式化，当人们使用 <code>make_system_error_code</code> 就可以将 Windows 错误信息保存到 <code>bela::error_code</code> 对象，利用 C++ RAII 机制，完全可以不用担心内存释放，同样你还可以使用 <code>bela::make_error_code</code> 构造自己的错误信息，<code>bela::make_error_code</code> 依赖 <code>bela::strings_internal::CatPieces</code>，因此，你可以像使用 <code>bela::StringCat</code> 使用 <code>bela::make_error_code</code></p><h2 id=stringcat>StringCat</h2><p><code>StringCat</code> 学习了 <code>absl::StrCat</code>，唯一的不同在于使用 <code>wchar_t</code> 作为字符基本类型，在 Windows 系统中，<code>StrCat</code> 实际上被 <code>shlwapi</code> 作为宏定义使用了，为了避免在使用 Windows API 时造成困惑，我将其命名为 <code>StringCat</code>。这种函数的好处是连接字符串时只需要一次内存分配，可以将基本类型转变为字符串类型，然后连接到一起，十分有用，并且，<code>bela::StringCat</code> 比 <code>absl::StrCat</code> 有趣的一点是支持 <code>char32_t</code> Unicode 码点，因此，你可以使用 <code>bela::StringCat</code> 连接 Unicode 码点来拼接 Emoji 或者其他字符，然后输出到 <code>Windows Terminal</code> 或者显示到文本或者使用 Dwrite 绘制到图形界面上。</p><p><code>StringCat</code> 定义在 <code>&lt;bela/strcat.hpp></code> 文件中。</p><h2 id=ascii>Ascii</h2><p>bela 学习了 <code>absl/strings/ascii.h</code> ，并将其移植到 <code>wchar_t</code>。在移植的时候要考虑在 Windows 系统上 <code>wchar_t</code> 的范围是 <code>0~65535</code>，因此一些函数需要判断大于 <code>0xFF</code> 时的策略。在 <code>&lt;bela/ascii.hpp></code> 文件中 <code>AsciiStrToUpper</code> ，<code>AsciiStrToLower</code>， <code>StripLeadingAsciiWhitespace</code>，<code>StripTrailingAsciiWhitespace</code>， <code>StripAsciiWhitespace</code> 这些函数十分有帮助。</p><h2 id=其他字符串函数>其他字符串函数</h2><table><thead><tr><th>函数</th><th>功能</th><th>文件</th></tr></thead><tbody><tr><td>StrSplit</td><td>字符串切割，Delimiter 支持按字符，按字符串或者按长度，支持跳过空或者空白，比 Golang 的 strings.Split 要好用一些</td><td><code>&lt;bela/str_split.hpp></code></td></tr><tr><td>StrReplaceAll</td><td>替换字符串</td><td><code>&lt;bela/str_replace.hpp></code></td></tr><tr><td>ConsumePrefix，ConsumeSuffix，StripPrefix，StripSuffix</td><td>删除特定前缀或者后缀</td><td><code>&lt;bela/strip.hpp></code></td></tr><tr><td>StartsWith，EndsWith，EqualsIgnoreCase，StartsWithIgnoreCase，EndsWithIgnoreCase</td><td>特定的比较函数，前两者 C++20 被引入（std::string::starts_with，std::string::ends_with），Visual 2019 16.1 C++ /std:c++latest 开启</td><td><code>&lt;bela/match.hpp></code></td></tr><tr><td>Substitute，SubstituteAndAppend</td><td>在前文 <a href=https://forcemz.net/cxx/2019/04/29/StringFormattingTalk/>《字符串格式化漫谈》</a> 有提及，字符串填充。</td><td><code>&lt;bela/subsitute.hpp></code></td></tr><tr><td>SimpleAtob，SimpleAtoi</td><td>字符串转整型或者 Boolean，要转换浮点类型，请使用 <code>&lt;bela/charconv.hpp></code></td><td><code>&lt;bela/numbers.hpp></code></td></tr></tbody></table><h2 id=编码转换>编码转换</h2><p>在 Bela 中，我基于 LLVM 的 ConvertUTF 实现了 UTF-16/UTF-8 UTF-32 的一些函数，声明文件均在 <code>&lt;bela/codecvt.hpp></code></p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>char32tochar16</td><td>Unicode 码点转 UTF-16，缓冲区长度应当至少为 2</td></tr><tr><td>char32tochar8</td><td>Unicode 码点转 UTF-8，缓冲区长度至少为 4</td></tr><tr><td>c16tomb</td><td>UTF16 编码转 UTF-8，低级 API</td></tr><tr><td>mbrtowc</td><td>UTF-8 编码转 UTF-16 (wchar_t)，低级 API</td></tr><tr><td>mbrtoc16</td><td>UTF-8 编码转 UTF-16 (char16_t)，低级 API</td></tr><tr><td>ToNarrow</td><td>UTF-16 转 UTF-8</td></tr><tr><td>ToWide</td><td>UTF-8 转 UTF-16</td></tr></tbody></table><p>涉及到编码转换时，应当使用高级 API <code>bela::ToNarrow</code> 和 <code>bela::ToWide</code></p><h2 id=strformat>StrFormat</h2><p>Bela 目前提供了一个类型安全简单的 <code>StrFormat</code>, <code>StrFormat</code> 基于 C++ 变参模板，使用 <code>union</code> 记录参数类型，在解析时按照输入的占位符将其他类型转换为字符串连接在一起，从而实现格式化功能。<code>bela::StrFormat</code> 借鉴了 <code>Chromium SafeNPrintf</code> 函数，但支持的类型要比 <code>SafeNPrintf</code> 多很多。</p><p>支持的类型和响应的占位符如下表所示：</p><table><thead><tr><th>类型</th><th>占位符</th><th>备注</th></tr></thead><tbody><tr><td>char</td><td><code>%c</code></td><td>ASCII 字符，会被提升为 wchar_t</td></tr><tr><td>unsigned char</td><td><code>%c</code></td><td>ASCII 字符，会被提升为 wchar_t</td></tr><tr><td>wchar_t</td><td><code>%c</code></td><td>UTF-16 字符</td></tr><tr><td>char16_t</td><td><code>%c</code></td><td>UTF-16 字符</td></tr><tr><td>char32_t</td><td><code>%c</code></td><td>UTF-32 Unicode 字符，会被转为 UTF-16 字符，这意味着可以使用 Unicode 码点以 %c 的方式输出 emoji。</td></tr><tr><td>short</td><td><code>%d</code></td><td>16位整型</td></tr><tr><td>unsigned short</td><td><code>%d</code></td><td>16位无符号整型</td></tr><tr><td>int</td><td><code>%d</code></td><td>32位整型</td></tr><tr><td>unsigned int</td><td><code>%d</code></td><td>32位无符号整型</td></tr><tr><td>long</td><td><code>%d</code></td><td>32位整型</td></tr><tr><td>unsigned long</td><td><code>%d</code></td><td>32位无符号整型</td></tr><tr><td>long long</td><td><code>%d</code></td><td>64位整型</td></tr><tr><td>unsigned long long</td><td><code>%d</code></td><td>64位无符号整型</td></tr><tr><td>float</td><td><code>%f</code></td><td>会被提升为 <code>double</code></td></tr><tr><td>double</td><td><code>%f</code></td><td>64位浮点</td></tr><tr><td>const char *</td><td><code>%s</code></td><td>UTF-8 字符串，会被转换成 UTF-16 字符串</td></tr><tr><td>char *</td><td><code>%s</code></td><td>UTF-8 字符串，会被转换成 UTF-16 字符串</td></tr><tr><td>std::string</td><td><code>%s</code></td><td>UTF-8 字符串，会被转换成 UTF-16 字符串</td></tr><tr><td>std::string_view</td><td><code>%s</code></td><td>UTF-8 字符串，会被转换成 UTF-16 字符串</td></tr><tr><td>const wchar_t *</td><td><code>%s</code></td><td>UTF-16 字符串</td></tr><tr><td>wchar_t *</td><td><code>%s</code></td><td>UTF-16 字符串</td></tr><tr><td>std::wstring</td><td><code>%s</code></td><td>UTF-16 字符串</td></tr><tr><td>std::wstring_view</td><td><code>%s</code></td><td>UTF-16 字符串</td></tr><tr><td>const char16_t *</td><td><code>%s</code></td><td>UTF-16 字符串</td></tr><tr><td>char16_t *</td><td><code>%s</code></td><td>UTF-16 字符串</td></tr><tr><td>std::u16string</td><td><code>%s</code></td><td>UTF-16 字符串</td></tr><tr><td>std::u16string_view</td><td><code>%s</code></td><td>UTF-16 字符串</td></tr><tr><td>void *</td><td><code>%p</code></td><td>指针类型，会格式化成 <code>0xffff00000</code> 这样的字符串</td></tr></tbody></table><p>如果不格式化 UTF-8 字符串，且拥有固定大小内存缓冲区，可以使用 <code>StrFormat</code> 的如下重载，此重载可以轻松的移植到 POSIX 系统并支持异步信号安全:</p><div class=highlight><pre tabindex=0 style=color:#1d2432;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff636f>template</span> <span style=color:#ff636f>&lt;</span><span style=color:#ff636f>typename</span>... <span style=color:#58a1dd>Args</span><span style=color:#ff636f>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#58a1dd>ssize_t</span> <span style=color:#58a1dd>StrFormat</span>(<span style=color:#ff636f>wchar_t</span> <span style=color:#ff636f>*</span><span style=color:#58a1dd>buf</span>, <span style=color:#58a1dd>size_t</span> <span style=color:#58a1dd>N</span>, <span style=color:#ff636f>const</span> <span style=color:#ff636f>wchar_t</span> <span style=color:#ff636f>*</span><span style=color:#58a1dd>fmt</span>, <span style=color:#58a1dd>Args</span>... <span style=color:#58a1dd>args</span>)
</span></span></code></pre></div><p>我们基于 <code>StrFormat</code> 实现了类型安全的 <code>bela::FPrintF</code>，这个函数能够根据输出设备的类型自动转换编码，如果是 <code>Conhost</code> 则会输出 <code>UTF-16</code>，否则则输出 <code>UTF-8</code>。如果 <code>Conhost</code> 不支持 <code>VT</code> 模式，bela 则会将输出字符串中的 ASCII 颜色转义去除，但 bela 并没有做 Windows 旧版本的适配，我们应该始终使用 Windows 最新发行版。</p><p>下面是一个示例：</p><div class=highlight><pre tabindex=0 style=color:#1d2432;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#828b96;font-style:italic>/// C++17
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic></span><span style=color:#828b96;font-style:italic>#include</span> <span style=color:#828b96;font-style:italic>&lt;bela/strcat.hpp&gt;</span><span style=color:#828b96;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic>#include</span> <span style=color:#828b96;font-style:italic>&lt;bela/stdwriter.hpp&gt;</span><span style=color:#828b96;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#ff636f>constexpr</span> <span style=color:#ff636f>auto</span> <span style=color:#58a1dd>cv</span><span style=color:#ff636f>=</span><span style=color:#58a1dd>__cplusplus</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff636f>int</span> <span style=color:#58a1dd>wmain</span>(<span style=color:#ff636f>int</span> <span style=color:#58a1dd>argc</span>, <span style=color:#ff636f>wchar_t</span> <span style=color:#ff636f>**</span><span style=color:#58a1dd>argv</span>) {
</span></span><span style=display:flex><span>  <span style=color:#ff636f>auto</span> <span style=color:#58a1dd>ux</span> <span style=color:#ff636f>=</span> <span style=color:#a6be9d>&#34;</span><span style=color:#a6be9d>\xf0\x9f\x98\x81</span><span style=color:#a6be9d> UTF-8 text </span><span style=color:#a6be9d>\xE3\x8D\xA4</span><span style=color:#a6be9d>&#34;</span>; <span style=color:#828b96;font-style:italic>// force encode UTF-8
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic></span>  <span style=color:#ff636f>wchar_t</span> <span style=color:#58a1dd>wx</span>[] <span style=color:#ff636f>=</span> <span style=color:#a6be9d>L</span><span style=color:#a6be9d>&#34;Engine </span><span style=color:#a6be9d>\xD83D\xDEE0</span><span style=color:#a6be9d> 中国&#34;</span>;
</span></span><span style=display:flex><span>  <span style=color:#58a1dd>bela</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>FPrintF</span>(
</span></span><span style=display:flex><span>      <span style=color:#58a1dd>stderr</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6be9d>L</span><span style=color:#a6be9d>&#34;Argc: %d Arg0: </span><span style=color:#a6be9d>\x1b</span><span style=color:#a6be9d>[32m%s</span><span style=color:#a6be9d>\x1b</span><span style=color:#a6be9d>[0m W: %s UTF-8: %s C++ version: %d</span><span style=color:#a6be9d>\n</span><span style=color:#a6be9d>&#34;</span>,  <span style=color:#58a1dd>argc</span>, <span style=color:#58a1dd>argv</span>[<span style=color:#a6be9d>0</span>], <span style=color:#58a1dd>wx</span>, <span style=color:#58a1dd>ux</span>, <span style=color:#58a1dd>cv</span>);
</span></span><span style=display:flex><span>  <span style=color:#ff636f>char32_t</span> <span style=color:#58a1dd>em</span> <span style=color:#ff636f>=</span> <span style=color:#a6be9d>0x1F603</span>;<span style=color:#828b96;font-style:italic>//😃
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic></span>  <span style=color:#ff636f>auto</span> <span style=color:#58a1dd>s</span> <span style=color:#ff636f>=</span> <span style=color:#58a1dd>bela</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>StringCat</span>(<span style=color:#a6be9d>L</span><span style=color:#a6be9d>&#34;Look emoji --&gt;&#34;</span>, <span style=color:#58a1dd>em</span>, <span style=color:#a6be9d>L</span><span style=color:#a6be9d>&#34; U: &#34;</span>,
</span></span><span style=display:flex><span>                           <span style=color:#ff636f>static_cast</span><span style=color:#ff636f>&lt;</span><span style=color:#ff636f>uint32_t</span><span style=color:#ff636f>&gt;</span>(<span style=color:#58a1dd>em</span>));
</span></span><span style=display:flex><span>  <span style=color:#58a1dd>bela</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>FPrintF</span>(<span style=color:#58a1dd>stderr</span>, <span style=color:#a6be9d>L</span><span style=color:#a6be9d>&#34;emoji test %c %s</span><span style=color:#a6be9d>\n</span><span style=color:#a6be9d>&#34;</span>, <span style=color:#58a1dd>em</span>, <span style=color:#58a1dd>s</span>);
</span></span><span style=display:flex><span>  <span style=color:#58a1dd>bela</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>FPrintF</span>(<span style=color:#58a1dd>stderr</span>, <span style=color:#a6be9d>L</span><span style=color:#a6be9d>&#34;hStderr Mode: %s hStdin Mode: %s</span><span style=color:#a6be9d>\n</span><span style=color:#a6be9d>&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#58a1dd>bela</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>FileTypeName</span>(<span style=color:#58a1dd>stderr</span>), <span style=color:#58a1dd>bela</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>FileTypeName</span>(<span style=color:#58a1dd>stdin</span>));
</span></span><span style=display:flex><span>  <span style=color:#ff636f>return</span> <span style=color:#a6be9d>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>请注意，如果上述 emoji 要正常显示，应当使用 <code>Windows Terminal</code> 或者是 <code>Mintty</code>。</p><h1 id=三-bela-windows-系统功能库>三. Bela Windows 系统功能库</h1><h2 id=belafinaly>bela::finaly</h2><p>在使用 Golang 时，<code>defer</code> 可以在函数退出时执行一些代码，在 C++ 中 <a href=https://github.com/microsoft/gsl>Microsoft/GSL</a> 里面有一个 <code>finaly</code> 实现，异曲同工。在这里 我们可以使用 <code>finaly</code> 避免资源泄露。</p><div class=highlight><pre tabindex=0 style=color:#1d2432;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#828b96;font-style:italic>#include</span> <span style=color:#828b96;font-style:italic>&lt;bela/finaly.hpp&gt;</span><span style=color:#828b96;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic>#include</span> <span style=color:#828b96;font-style:italic>&lt;cstdio&gt;</span><span style=color:#828b96;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#ff636f>int</span> <span style=color:#58a1dd>wmain</span>(){
</span></span><span style=display:flex><span>  <span style=color:#ff636f>auto</span> <span style=color:#58a1dd>file</span><span style=color:#ff636f>=</span><span style=color:#58a1dd>fopen</span>(<span style=color:#a6be9d>&#34;somelog&#34;</span>,<span style=color:#a6be9d>&#34;w+&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#ff636f>auto</span> <span style=color:#58a1dd>closer</span><span style=color:#ff636f>=</span><span style=color:#58a1dd>bela</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>finaly</span>([<span style=color:#ff636f>&amp;</span>]{
</span></span><span style=display:flex><span>    <span style=color:#ff636f>if</span>(<span style=color:#58a1dd>file</span><span style=color:#ff636f>!=</span><span style=color:#ff636f>nullptr</span>){
</span></span><span style=display:flex><span>      <span style=color:#58a1dd>fclose</span>(<span style=color:#58a1dd>file</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>  <span style=color:#828b96;font-style:italic>/// do some codes
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic></span>  <span style=color:#ff636f>return</span> <span style=color:#a6be9d>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=pathcat-路径规范化连接函数>PathCat 路径规范化连接函数</h2><p><code>PathCat</code> 函数借鉴了 <code>StringCat</code> 函数，将路径组件连接起来。例子如下：</p><div class=highlight><pre tabindex=0 style=color:#1d2432;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>  <span style=color:#ff636f>auto</span> <span style=color:#58a1dd>p</span> <span style=color:#ff636f>=</span> <span style=color:#58a1dd>bela</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>PathCat</span>(<span style=color:#a6be9d>L</span><span style=color:#a6be9d>&#34;</span><span style=color:#a6be9d>\\\\</span><span style=color:#a6be9d>?</span><span style=color:#a6be9d>\\</span><span style=color:#a6be9d>C:</span><span style=color:#a6be9d>\\</span><span style=color:#a6be9d>Windows/System32&#34;</span>, <span style=color:#a6be9d>L</span><span style=color:#a6be9d>&#34;drivers/etc&#34;</span>, <span style=color:#a6be9d>L</span><span style=color:#a6be9d>&#34;hosts&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#58a1dd>bela</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>FPrintF</span>(<span style=color:#58a1dd>stderr</span>, <span style=color:#a6be9d>L</span><span style=color:#a6be9d>&#34;PathCat: %s</span><span style=color:#a6be9d>\n</span><span style=color:#a6be9d>&#34;</span>, <span style=color:#58a1dd>p</span>);
</span></span><span style=display:flex><span>  <span style=color:#ff636f>auto</span> <span style=color:#58a1dd>p2</span> <span style=color:#ff636f>=</span> <span style=color:#58a1dd>bela</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>PathCat</span>(<span style=color:#a6be9d>L</span><span style=color:#a6be9d>&#34;C:</span><span style=color:#a6be9d>\\</span><span style=color:#a6be9d>Windows/System32&#34;</span>, <span style=color:#a6be9d>L</span><span style=color:#a6be9d>&#34;drivers/../..&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#58a1dd>bela</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>FPrintF</span>(<span style=color:#58a1dd>stderr</span>, <span style=color:#a6be9d>L</span><span style=color:#a6be9d>&#34;PathCat: %s</span><span style=color:#a6be9d>\n</span><span style=color:#a6be9d>&#34;</span>, <span style=color:#58a1dd>p2</span>);
</span></span><span style=display:flex><span>  <span style=color:#ff636f>auto</span> <span style=color:#58a1dd>p3</span> <span style=color:#ff636f>=</span> <span style=color:#58a1dd>bela</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>PathCat</span>(<span style=color:#a6be9d>L</span><span style=color:#a6be9d>&#34;Windows/System32&#34;</span>, <span style=color:#a6be9d>L</span><span style=color:#a6be9d>&#34;drivers/./././.</span><span style=color:#a6be9d>\\</span><span style=color:#a6be9d>.</span><span style=color:#a6be9d>\\</span><span style=color:#a6be9d>etc&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#58a1dd>bela</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>FPrintF</span>(<span style=color:#58a1dd>stderr</span>, <span style=color:#a6be9d>L</span><span style=color:#a6be9d>&#34;PathCat: %s</span><span style=color:#a6be9d>\n</span><span style=color:#a6be9d>&#34;</span>, <span style=color:#58a1dd>p3</span>);
</span></span><span style=display:flex><span>  <span style=color:#ff636f>auto</span> <span style=color:#58a1dd>p4</span> <span style=color:#ff636f>=</span> <span style=color:#58a1dd>bela</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>PathCat</span>(<span style=color:#a6be9d>L</span><span style=color:#a6be9d>&#34;.&#34;</span>, <span style=color:#a6be9d>L</span><span style=color:#a6be9d>&#34;test/pathcat/./pathcat_test.exe&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#58a1dd>bela</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>FPrintF</span>(<span style=color:#58a1dd>stderr</span>, <span style=color:#a6be9d>L</span><span style=color:#a6be9d>&#34;PathCat: %s</span><span style=color:#a6be9d>\n</span><span style=color:#a6be9d>&#34;</span>, <span style=color:#58a1dd>p4</span>);
</span></span></code></pre></div><p><code>PathCat</code> 的思路是先将 <code>UNC</code> 前缀和盘符记录并去除，然后将所有的参数使用 <code>PathSpilt</code> 函数以 Windows 路径分隔符和 Linux 路径分隔符拆分成 <code>std::wstring_view</code> 数组，当当前路径元素为 <code>..</code> 时，弹出字符串数组一个元素，如果为 <code>.</code> 则保持不变，否则将路径元素压入数组。拆分完毕后，遍历数组计算所需缓冲区大小，调整 <code>std::wstring</code> 容量，然后进行路径重组。</p><p>当第一个参数值为 <code>.</code> 时，<code>PathCat</code> 将解析第一个路径为当前目录，然后参与解析。如果 <code>PathCat</code> 第一个参数是相对路径，<code>PathCat</code> 并不会主动将路径转变为绝对路径，因此，你应当主动的将第一个参数设置为 <code>.</code> 以期解析为绝对路径。</p><p><code>PathCat</code> 并不会判断路径是否存在，因此需要注意。</p><p>路径解析错误是很多软件的漏洞根源，合理的规范化路径非常有必要，而 <code>PathCat</code> 在规范化路径时，使用 C++17/C++20(Span) 的特性，减少内存分配，简化了规范化流程。</p><p><code>PathCat</code> 使用了 <code>bela::Span</code> （<code>&lt;bela/span.hpp></code>），<code>Span</code> 被 C++20 采纳，<code>bela::Span</code> 基于 <code>absl::Span</code>。</p><h2 id=pathexists-函数>PathExists 函数</h2><p><code>PathExists</code> 函数判断路径是否存在，当使用默认参数时，只会判断路径是否存在，如果需要判断路径的其他属性，可以使用如下方式：</p><div class=highlight><pre tabindex=0 style=color:#1d2432;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff636f>if</span>(<span style=color:#ff636f>!</span><span style=color:#58a1dd>bela</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>PathExists</span>(<span style=color:#a6be9d>L</span><span style=color:#a6be9d>&#34;C:</span><span style=color:#a6be9d>\\</span><span style=color:#a6be9d>Windows&#34;</span>,<span style=color:#58a1dd>FileAttribute</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>Dir</span>)){
</span></span><span style=display:flex><span>    <span style=color:#58a1dd>bela</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>FPrintF</span>(<span style=color:#58a1dd>stderr</span>,<span style=color:#a6be9d>L</span><span style=color:#a6be9d>&#34;C:</span><span style=color:#a6be9d>\\</span><span style=color:#a6be9d>Windows not dir or not exists</span><span style=color:#a6be9d>\n</span><span style=color:#a6be9d>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=lookuprealpath-函数>LookupRealPath 函数</h2><p><code>LookupRealPath</code> 用于解析 Windows 符号链接和卷挂载点。</p><h2 id=lookupappexeclinktarget-函数>LookupAppExecLinkTarget 函数</h2><p><code>LookupAppExecLinkTarget</code> 用于解析 Windows AppExecLink 目标，在 Windows 10 系统中，<code>AppExecLink</code> 是一种 Store App 的命令行入口，通常位于 <code>C:\Users\$Username\AppData\Local\Microsoft\WindowsApps</code>，这种文件本质上是一种重解析点，因此解析时需要按照重解析点的方法去解析。</p><h2 id=executableexistsinpath-查找可执行文件>ExecutableExistsInPath 查找可执行文件</h2><p>在 Windows cmd 中，有一个命令叫做 <code>where</code>，用于查找命令或者可执行文件的路径，而 <code>ExecutableExistsInPath</code> 则提供了相同的功能，我们可以按照输入的命令或者路径查找对应的可执行文件，这里有一个 <code>where</code> 实现：</p><div class=highlight><pre tabindex=0 style=color:#1d2432;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#828b96;font-style:italic>////
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic></span><span style=color:#828b96;font-style:italic>#include</span> <span style=color:#828b96;font-style:italic>&lt;bela/strcat.hpp&gt;</span><span style=color:#828b96;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic>#include</span> <span style=color:#828b96;font-style:italic>&lt;bela/stdwriter.hpp&gt;</span><span style=color:#828b96;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic>#include</span> <span style=color:#828b96;font-style:italic>&lt;bela/path.hpp&gt;</span><span style=color:#828b96;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#ff636f>int</span> <span style=color:#58a1dd>wmain</span>(<span style=color:#ff636f>int</span> <span style=color:#58a1dd>argc</span>, <span style=color:#ff636f>wchar_t</span> <span style=color:#ff636f>**</span><span style=color:#58a1dd>argv</span>) {
</span></span><span style=display:flex><span>  <span style=color:#ff636f>if</span> (<span style=color:#58a1dd>argc</span> <span style=color:#ff636f>&lt;</span> <span style=color:#a6be9d>2</span>) {
</span></span><span style=display:flex><span>    <span style=color:#58a1dd>bela</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>FPrintF</span>(<span style=color:#58a1dd>stderr</span>, <span style=color:#a6be9d>L</span><span style=color:#a6be9d>&#34;usage: %s command</span><span style=color:#a6be9d>\n</span><span style=color:#a6be9d>&#34;</span>, <span style=color:#58a1dd>argv</span>[<span style=color:#a6be9d>0</span>]);
</span></span><span style=display:flex><span>    <span style=color:#ff636f>return</span> <span style=color:#a6be9d>1</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#58a1dd>std</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>wstring</span> <span style=color:#58a1dd>exe</span>;
</span></span><span style=display:flex><span>  <span style=color:#ff636f>if</span> (<span style=color:#ff636f>!</span><span style=color:#58a1dd>bela</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>ExecutableExistsInPath</span>(<span style=color:#58a1dd>argv</span>[<span style=color:#a6be9d>1</span>], <span style=color:#58a1dd>exe</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#58a1dd>bela</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>FPrintF</span>(<span style=color:#58a1dd>stderr</span>, <span style=color:#a6be9d>L</span><span style=color:#a6be9d>&#34;command not found: %s</span><span style=color:#a6be9d>\n</span><span style=color:#a6be9d>&#34;</span>, <span style=color:#58a1dd>argv</span>[<span style=color:#a6be9d>1</span>]);
</span></span><span style=display:flex><span>    <span style=color:#ff636f>return</span> <span style=color:#a6be9d>1</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#58a1dd>bela</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>FPrintF</span>(<span style=color:#58a1dd>stdout</span>, <span style=color:#a6be9d>L</span><span style=color:#a6be9d>&#34;%s</span><span style=color:#a6be9d>\n</span><span style=color:#a6be9d>&#34;</span>, <span style=color:#58a1dd>exe</span>);
</span></span><span style=display:flex><span>  <span style=color:#ff636f>return</span> <span style=color:#a6be9d>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=命令行合成拆分和解析>命令行合成，拆分和解析</h2><p>在 bela 中，我们提供了命令行合成，拆分和解析类，具体如下：</p><table><thead><tr><th>类名</th><th>功能</th><th>文件</th></tr></thead><tbody><tr><td>ParseArgv</td><td>解析命令行参数，类似 GNU <code>getopt_long</code>，支持 <code>wchar_t</code>，不使用全局变量，错误信息详细</td><td><code>&lt;bela/parseargv.hpp></code></td></tr><tr><td>Tokenizer</td><td>将命令行字符串 Windows commandline 形式转变为 <code>wchar_t **Argv</code> 形式</td><td><code>&lt;bela/tokenizecmdline.hpp></code></td></tr><tr><td>EscapeArgv</td><td>将 <code>Argv</code> 形式命令行参数转为 <code>commdline</code> 形式，主要用于 <code>CreateProcess</code></td><td><code>&lt;bela/escapeargv.hpp></code></td></tr></tbody></table><h2 id=mapview>MapView</h2><p>在 bela 中，我还提供 <code>MapView</code>，这是一个只读的文件内存映射，通常用于文件解析。文件 <code>&lt;bela/mapview.hpp></code> 还有与 <code>std::string_view</code> 类似的 <code>MemView </code>类。</p><h2 id=pesimpledetailsaze-获得-pe-的简单信息>PESimpleDetailsAze 获得 PE 的简单信息</h2><p>在 Bela 中，我添加了一个 <code>PESimpleDetailsAze</code> 用于获得 PE 可执行文件的一些信息，其结构体如下：</p><div class=highlight><pre tabindex=0 style=color:#1d2432;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ff636f>struct</span> <span style=color:#58a1dd>PESimpleDetails</span> {
</span></span><span style=display:flex><span>  <span style=color:#58a1dd>std</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>wstring</span> <span style=color:#58a1dd>clrmsg</span>;
</span></span><span style=display:flex><span>  <span style=color:#58a1dd>std</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>vector</span><span style=color:#ff636f>&lt;</span><span style=color:#58a1dd>std</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>wstring</span><span style=color:#ff636f>&gt;</span> <span style=color:#58a1dd>depends</span>; <span style=color:#828b96;font-style:italic>// depends dll
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic></span>  <span style=color:#58a1dd>std</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>vector</span><span style=color:#ff636f>&lt;</span><span style=color:#58a1dd>std</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>wstring</span><span style=color:#ff636f>&gt;</span> <span style=color:#58a1dd>delays</span>;  <span style=color:#828b96;font-style:italic>// delay load library
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic></span>  <span style=color:#58a1dd>PEVersionPair</span> <span style=color:#58a1dd>osver</span>;
</span></span><span style=display:flex><span>  <span style=color:#58a1dd>PEVersionPair</span> <span style=color:#58a1dd>linkver</span>;
</span></span><span style=display:flex><span>  <span style=color:#58a1dd>PEVersionPair</span> <span style=color:#58a1dd>imagever</span>;
</span></span><span style=display:flex><span>  <span style=color:#58a1dd>Machine</span> <span style=color:#58a1dd>machine</span>;
</span></span><span style=display:flex><span>  <span style=color:#58a1dd>Subsytem</span> <span style=color:#58a1dd>subsystem</span>;
</span></span><span style=display:flex><span>  <span style=color:#ff636f>uint16_t</span> <span style=color:#58a1dd>characteristics</span>{<span style=color:#a6be9d>0</span>};
</span></span><span style=display:flex><span>  <span style=color:#ff636f>uint16_t</span> <span style=color:#58a1dd>dllcharacteristics</span>{<span style=color:#a6be9d>0</span>};
</span></span><span style=display:flex><span>  <span style=color:#ff636f>bool</span> <span style=color:#58a1dd>IsConsole</span>() <span style=color:#ff636f>const</span> { <span style=color:#ff636f>return</span> <span style=color:#58a1dd>subsystem</span> <span style=color:#ff636f>==</span> <span style=color:#58a1dd>Subsytem</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>CUI</span>; }
</span></span><span style=display:flex><span>  <span style=color:#ff636f>bool</span> <span style=color:#58a1dd>IsDLL</span>() <span style=color:#ff636f>const</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff636f>constexpr</span> <span style=color:#ff636f>uint16_t</span> <span style=color:#58a1dd>imagefiledll</span> <span style=color:#ff636f>=</span> <span style=color:#a6be9d>0x2000</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff636f>return</span> (<span style=color:#58a1dd>characteristics</span> <span style=color:#ff636f>&amp;</span> <span style=color:#58a1dd>imagefiledll</span>) <span style=color:#ff636f>!=</span> <span style=color:#a6be9d>0</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>函数的声明如下：</p><div class=highlight><pre tabindex=0 style=color:#1d2432;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#58a1dd>std</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>optional</span><span style=color:#ff636f>&lt;</span><span style=color:#58a1dd>PESimpleDetails</span><span style=color:#ff636f>&gt;</span> <span style=color:#58a1dd>PESimpleDetailsAze</span>(<span style=color:#58a1dd>std</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>wstring_view</span> <span style=color:#58a1dd>file</span>,
</span></span><span style=display:flex><span>                                                      <span style=color:#58a1dd>bela</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>error_code</span> <span style=color:#ff636f>&amp;</span><span style=color:#58a1dd>ec</span>);
</span></span></code></pre></div><p>通过此函数，你可以获得 PE 可执行文件的目标机器类型，子系统，连接器版本，系统版本，Image 版本，PE 的特征，PE 依赖的 dll 和延时加载的 dll。如果是 CLR PE 文件，则clrmsg 不为空描述的是 CLR 的信息。<code>PESimpleDetailsAze</code> 并不依赖 <code>DbgHelp.dll (ImageRvaToVa)</code>。</p><h1 id=最后>最后</h1><p>Bela 应该是不断发展的，如果我有新的 Idea 了，就会及时的移植进去的。</p><hr width=100% id=EOF><p style=color:#777>Last modified on 2019-05-25</p></div></div><nav class=post-pagination><a class=newer-posts href=/posts/2019/2019-06-25-talk-computer-update/>Next<br>坐和放宽 - 您的计算机需要更新
</a><a class=older-posts href=/posts/2019/2019-04-29-string-formatting-talk/>Previous<br>字符串格式化漫谈</a></nav><div class=post-comment-wrapper></div></div></div></div></div><div id=sideContainer class=side-container><a class="a-block nav-head false" href=https://forcemz.net/><div class=nav-title>Charlie's Rethinking</div><div class=nav-subtitle>Themed by Diary.</div></a><div class=nav-link-list><a class="a-block nav-link-item active" href=/posts>归档
</a><a class="a-block nav-link-item false" href=/categories>分类
</a><a class="a-block nav-link-item false" href=/tags>标签
</a><a class="a-block nav-link-item false" href=/about>关于
</a><a class="a-block nav-link-item false" href=/index.xml>RSS Feed</a></div><div class=nav-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://risehere.net/>Rise</a><br>Ported from <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
Copyright (c) 2009-2024 J23</div></div><div id=extraContainer class=extra-container><div class=toc-wrapper><div class=toc><div class=toc-content><center>- CATALOG -</center><ul><li><a href=#%e5%89%8d%e8%a8%80 class=nav-前言>前言</a></li><li><a href=#%e4%b8%80-bela-%e7%9a%84%e7%bc%98%e7%94%b1 class=nav-一-bela-的缘由>一. Bela 的缘由</a></li><li><a href=#%e4%ba%8c-bela-%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%8a%9f%e8%83%bd%e5%ba%93 class=nav-二-bela-字符串功能库>二. Bela 字符串功能库</a></li><ul><li><a href=#belaerror_code class=nav-belaerror_code>bela::error_code</a></li><li><a href=#stringcat class=nav-stringcat>StringCat</a></li><li><a href=#ascii class=nav-ascii>Ascii</a></li><li><a href=#%e5%85%b6%e4%bb%96%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%87%bd%e6%95%b0 class=nav-其他字符串函数>其他字符串函数</a></li><li><a href=#%e7%bc%96%e7%a0%81%e8%bd%ac%e6%8d%a2 class=nav-编码转换>编码转换</a></li><li><a href=#strformat class=nav-strformat>StrFormat</a></li></ul><li><a href=#%e4%b8%89-bela-windows-%e7%b3%bb%e7%bb%9f%e5%8a%9f%e8%83%bd%e5%ba%93 class=nav-三-bela-windows-系统功能库>三. Bela Windows 系统功能库</a></li><ul><li><a href=#belafinaly class=nav-belafinaly>bela::finaly</a></li><li><a href=#pathcat-%e8%b7%af%e5%be%84%e8%a7%84%e8%8c%83%e5%8c%96%e8%bf%9e%e6%8e%a5%e5%87%bd%e6%95%b0 class=nav-pathcat-路径规范化连接函数>PathCat 路径规范化连接函数</a></li><li><a href=#pathexists-%e5%87%bd%e6%95%b0 class=nav-pathexists-函数>PathExists 函数</a></li><li><a href=#lookuprealpath-%e5%87%bd%e6%95%b0 class=nav-lookuprealpath-函数>LookupRealPath 函数</a></li><li><a href=#lookupappexeclinktarget-%e5%87%bd%e6%95%b0 class=nav-lookupappexeclinktarget-函数>LookupAppExecLinkTarget 函数</a></li><li><a href=#executableexistsinpath-%e6%9f%a5%e6%89%be%e5%8f%af%e6%89%a7%e8%a1%8c%e6%96%87%e4%bb%b6 class=nav-executableexistsinpath-查找可执行文件>ExecutableExistsInPath 查找可执行文件</a></li><li><a href=#%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%90%88%e6%88%90%e6%8b%86%e5%88%86%e5%92%8c%e8%a7%a3%e6%9e%90 class=nav-命令行合成拆分和解析>命令行合成，拆分和解析</a></li><li><a href=#mapview class=nav-mapview>MapView</a></li><li><a href=#pesimpledetailsaze-%e8%8e%b7%e5%be%97-pe-%e7%9a%84%e7%ae%80%e5%8d%95%e4%bf%a1%e6%81%af class=nav-pesimpledetailsaze-获得-pe-的简单信息>PESimpleDetailsAze 获得 PE 的简单信息</a></li></ul><li><a href=#%e6%9c%80%e5%90%8e class=nav-最后>最后</a></li></ul></div></div></div><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up
</i></a><a type=button class=pagination-action id=darkModeToggleButton><span class="material-icons pagination-action-icon" id=darkModeToggleIcon>dark_mode</span></a></div></div><div id=single-column-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://risehere.net/>Rise</a><br>Ported from <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
Copyright (c) 2009-2024 J23</div></div><script src=/js/journal.js></script></body></html>