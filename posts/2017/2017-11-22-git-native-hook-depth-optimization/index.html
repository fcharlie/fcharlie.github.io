<!doctype html><html lang=en><head><title>Git 原生钩子的深度优化</title>
<meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=5,user-scalable=5" name=viewport><meta content="telephone=no" name=format-detection><meta name=description content><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><script src=/js/toc.js></script><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><link rel=stylesheet href=/scss/dark-mode.min.cb53f1bee2b8900cb4f082afbf00175d6618f281cf9a2fe8619e3b52d20b5721.css integrity="sha256-y1PxvuK4kAy08IKvvwAXXWYY8oHPmi/oYZ47UtILVyE=" media=screen><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Material+Icons"></head><body><div id=app><div class=single-column-drawer-container id=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item active" href=/posts>归档
</a><a class="a-block drawer-menu-item false" href=/categories>分类
</a><a class="a-block drawer-menu-item false" href=/tags>标签
</a><a class="a-block drawer-menu-item false" href=/about>关于
</a><a class="a-block drawer-menu-item false" href=/index.xml>RSS Feed</a><div class=toc><div class=toc-content><center>- CATALOG -</center><ul><ul><li><a href=#%e5%89%8d%e8%a8%80 class=nav-前言>前言</a></li><li><a href=#gitlab-%e7%9a%84-update-%e9%92%a9%e5%ad%90 class=nav-gitlab-的-update-钩子>Gitlab 的 Update 钩子</a></li><li><a href=#%e5%ae%8c%e5%85%a8%e6%a3%80%e6%b5%8b%e7%9a%84-git-%e5%8e%9f%e7%94%9f%e9%92%a9%e5%ad%90 class=nav-完全检测的-git-原生钩子>完全检测的 Git 原生钩子</a></li><li><a href=#%e5%8e%9f%e7%94%9f%e9%92%a9%e5%ad%90%e4%bd%bf%e7%94%a8%e7%8e%af%e5%a2%83%e9%9a%94%e7%a6%bb%e7%89%b9%e6%80%a7 class=nav-原生钩子使用环境隔离特性>原生钩子使用环境隔离特性</a></li><li><a href=#%e5%bb%b6%e6%97%b6%e8%af%bb%e7%9a%84%e5%8e%9f%e7%94%9f%e9%92%a9%e5%ad%90 class=nav-延时读的原生钩子>延时读的原生钩子</a></li><li><a href=#%e5%88%a9%e7%94%a8%e5%86%85%e5%ad%98%e5%b8%83%e5%b1%80%e5%87%8f%e5%b0%91%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e6%ac%a1%e6%95%b0 class=nav-利用内存布局减少系统调用次数>利用内存布局减少系统调用次数</a></li><li><a href=#%e6%9b%b4%e5%a4%a7%e7%9a%84%e5%a4%a7%e6%96%87%e4%bb%b6%e6%a3%80%e6%b5%8b class=nav-更大的大文件检测>更大的大文件检测</a></li><li><a href=#pack-%e6%96%87%e4%bb%b6%e6%a0%bc%e5%bc%8f%e9%99%90%e5%88%b6 class=nav-pack-文件格式限制>Pack 文件格式限制</a></li><li><a href=#%e6%a3%80%e6%b5%8b%e4%bd%95%e6%97%b6%e5%bc%95%e5%85%a5%e5%a4%a7%e6%96%87%e4%bb%b6 class=nav-检测何时引入大文件>检测何时引入大文件</a></li><li><a href=#%e6%9c%80%e5%90%8e class=nav-最后>最后</a></li></ul></div></div></div></div></div><transition name=fade><div id=drawer-mask v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav id=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div id=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu
</i></button>
<a id=navTitle class=navbar-brand href=https://forcemz.net/>Charlie's Rethinking
</a><button type=button class=nav-darkmode-toggle id=darkModeToggleButton2>
<i class=material-icons id=darkModeToggleIcon2>dark_mode</i></button></div></nav><div class=single-column-header-container id=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=https://forcemz.net/><div class=single-column-header-title>Charlie's Rethinking</div><div class=single-column-header-subtitle>Themed by Diary.</div></a></div><div id=content><div id=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only><div class=post-title>Git 原生钩子的深度优化<div class=post-meta><time itemprop=datePublished>2017-11-22 10:00
</time><i class=material-icons>folder</i>
<a href=/categories/git>git</a>
&nbsp;</div></div></div><div class=post-body-wrapper><div class=post-body v-pre><h2 id=前言>前言</h2><p>Git 是最流行的版本控制工具，和大多数版本控制工具一样，Git 也拥有钩子特性，用户可以利用钩子实现一些附加功能，在 《Pro Git v2》 中，对钩子类型，消息格式等有详细介绍： <a href=https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks>8.3 Customizing Git - Git Hooks</a>。</p><p>代码托管平台也会使用钩子，一般是使用 <strong>Server-Side Hooks</strong>。包括 <strong>pre-receive</strong> <strong>update</strong> <strong>post-receive</strong>。</p><p>为什么要使用钩子？我们得先思考目前的 git 代码托管平台架构大多数是无状态的，也就是说 Web 是 Web, git 是 git。究其原因，目前服务器上的 git 传输实现基本上还是使用 git 命令做 smart 传输，这种传输本质上是一对命令做输入输出交换，类似 inetd。这种协议的缺陷在于：在子进程中传输的数据是隔离的，不透明的，不可控的。启动 Git 子命令后，权限控制，大文件检测等操作已不是 SSH 或者 HTTP 服务器能控制的了。当然，劫持网络数据进行深度分析是可以的，但那相当于重新实现一套 git。并且，这种性能上的损失也是平台不可接受的。
代码托管平台绝不能裹足不前，对于不适合的数据推送当然要拒绝他！幸运的是，我们还可以使用 hook 来阻挡不合适的数据推送了。</p><h2 id=gitlab-的-update-钩子>Gitlab 的 Update 钩子</h2><p>码云最初利用 Gitlab 搭建起来，而钩子的使用策略是 Gitlab 早先的策略，即使用 <strong>Update</strong> 钩子。Sidekiq, 以及后来推出的分支保护功能以及大文件检测，都是利用 <strong>Update</strong> 钩子实现的。这块代码是在 Gitlab-Shell 中。保护分支实际上是在运行 Update 钩子时，请求 Gitlab 判断引用是否被允许修改。而大文件检测则是使用 <strong>Commit-Between</strong> 进行一个回溯 <strong>diff</strong>，深度最大为 <em>20</em>。Sidekiq 则是插入 redis 队列实现的。</p><p>我们知道推送代码时需要在远程服务器中运行 <code>git-receive-pack</code> 命令，<code>recieve-pack</code> 会在整个生命周期运行三种钩子，也就是前面所说的 <strong>Server-Side Hooks</strong>（这里当然有个前提，钩子不存在就不会被调用），<strong>Update</strong> 是第二个被调用的钩子。receive-pack 将使用如下命令执行钩子：</p><pre tabindex=0><code>$GIT_DIR/hooks/update refname oldrev newrev
</code></pre><p>每更新一个引用执行一次，当钩子返回值不为零时，当前引用不会被更新。</p><p>新建分支时，oldrev 值为 <code>0000000000000000000000000000000000000000</code>。<br>删除分支时，newrev 值为 <code>0000000000000000000000000000000000000000</code>。</p><p>既然每一个引用都会执行一次，那么我们试想一下，一次性推送多个分支，并且分支都是新建分支，那么可以预见，无论是 <strong>Commit-Between Diff</strong> 还是保护分支还是任务队列的消耗时间都是成倍增加的。事实上也是如此，我们在测试服务器上推送大存储库，多分支，多 commit 时就发现了这个问题。</p><p>由于 <strong>Commit-Between Diff</strong> 深度的限制，一个精心构造的大文件是能够被推送到服务器而不被拒绝。</p><h2 id=完全检测的-git-原生钩子>完全检测的 Git 原生钩子</h2><p>既然 Update 钩子并不好，我们就得使用替代方案。<strong>pre-receive</strong> 是第一个被 receive-pack 调用的钩子，没有额外的命令行参数，无论更新多少引用都只会调用一次，引用列表会被 receive-pack 写入到 pre-receive 钩子进程的标准输入。格式原语如下：</p><pre tabindex=0><code>refname SP oldrev SP newrev LF
refnameN SP oldrev SP newrev LF
</code></pre><p>这个时候，我们可以将保护分支功能移入到此钩子，使用此钩子实现保护分支与 update 不一致的是同时推送多个引用，一旦有一个分支被拒绝，所有的分支都会被拒绝，而 update 钩子并不是如此。不过带来的好处是显而易见的，在推送镜像存储库，多分支项目时，可以避免多次发起对 Gitlab 的网络请求。</p><p><strong>post-receive</strong> 是最后被调用的钩子，格式与 <strong>pre-receive</strong> 完全一致，我们不能使用 pre-receive 更新 Sidekiq ，这是由于只有再在调用 update 钩子后，引用才会被更新，若 Sidekiq 在 pre-receive 钩子执行期间就响应可能会导致错误，因此在 post-receive 中更新 Sidekiq（redis）才是最安全的，在 post-receive 中执行 redis 命令还可以利用 KeepAlive 减少对 redis 的请求次数，从而优化服务器内部的网络。</p><p>update 钩子最后的功能只剩大文件检测了。如果将此功能移除，就完全不再需要 update 钩子。</p><p>在前面的博客：<a href=http://forcemz.net/git/2016/07/09/GitStorage/>Git 存储格式与运用</a>，我正是直接解析 pack/idx 文件格式来实现大文件检测。</p><p>一开始，我还使用 zip 解压松散文件读取文件大小，然后在 pack 文件中使用 libgit2 解析原始文件大小。实际上这种事情意义并不大，远程服务器上的存储库是一个 <em>bare</em> 存储库，所有的文件都是被压缩的，我们在统计存储库大小的时候也只是统计裸仓库的 <em>objects</em> 目录占用空间大小，因此，我们不需要检测原始文件大小，这样一来，钩子能够避免检测原始大小带来的性能损失。（实际上检测原始大小有个策略，只有超过一定值的对象才会检测原始大小用来判断文件是否超大。）</p><p>原生钩子使用 C++ 开发，经测试，效率远比 Update 钩子效率高，实际上 <strong>Update</strong> 钩子在解析 commit 的过程中就避免不了性能损失了。</p><p>这个时候的原生钩子还有一些不足，比如一些大的 pack 文件需要频繁检测，因此，我还实现了一个缓存机制，将 pack 检测到的数据写入到缓存文件中，避免频繁检测对应的 pack。这一点，我们需要知道，pack 文件一旦内容改变，名字也会改变，名字格式为 <code>pack-$sha1.pack</code>。</p><h2 id=原生钩子使用环境隔离特性>原生钩子使用环境隔离特性</h2><p>在 Git 2.11.0 时，git 改进了其推送的工作流程，增加了 <a href=https://git-scm.com/docs/git-receive-pack#_quarantine_environment><strong>Quarantine Environment</strong></a> 机制，此时，receive-pack 将会把所有推送的对象放置在隔离的临时目录中，一旦推送被接受才会将对象移动到常规的主对象目录，环境隔离的机制在整个 pre-receive 钩子的生命周期中是有效的。启动 update 钩子之前就会失效。</p><p>因此，我将原生钩子使用环境隔离机制进行改造。好处显而易见，只需要检测隔离目录中的 pack。pack 缓存也不再需要了。对于大文件检测的效果更明显，比如超出警告的大文件只会在第一次推送时发出警告，提高了用户体验。</p><p>当推送被拒绝时，临时目录会被删除，这样能够避免重复的失败推送回带来大量悬空对象，造成存储库的无效膨胀，存储库的无效膨胀会占用用户的配额，而清理无效膨胀需要使用 <code>git gc</code> 命令 （git gc &ndash;prune=now）。频繁的运行 GC 也会给服务器带来过重的压力。</p><p>由于在 update 钩子执行时，环境隔离已经失效，这种特性也就决定了 update 钩子无法胜任这些工作。</p><p>而 Gitlab 也支持了此特性 ：<a href=https://gitlab.com/artofhuman/gitlab-ce/commit/022242c30fe463d2b82c18c687088786b306415f>Accept environment variables from the <code>pre-receive</code> script</a></p><p>环境隔离需要理解几个环境变量：</p><div class=highlight><pre tabindex=0 style=color:#1d2432;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#58a1dd>$GIT_QUARANTINE_PATH</span>
</span></span><span style=display:flex><span><span style=color:#58a1dd>$GIT_OBJECT_DIRECTORY</span>
</span></span><span style=display:flex><span><span style=color:#58a1dd>$GIT_ALTERNATE_OBJECT_DIRECTORIES</span>
</span></span></code></pre></div><p>我只用到了 <code>GIT_QUARANTINE_PATH</code>。</p><p>在 git 2.15.0 之前的版本中，如果在隔离目录中运行 git update-ref 会损坏存储库，之后的版本已经拒绝了 git update-ref 在隔离目录中运行。</p><h2 id=延时读的原生钩子>延时读的原生钩子</h2><p>我在解析 pack 文件时，设计了一个 <code>ObjectIndex</code> 结构，读取 index 文件中关于 pack 中的文件数目后，使用一个 vector 存储对象。将所有的偏移依次读取，然后通过 std::sort 将偏移按大到小排序，依次相减，就得到对应的对象压缩后的体积。然后判断是否超限。</p><div class=highlight><pre tabindex=0 style=color:#1d2432;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ff636f>struct</span> <span style=color:#58a1dd>ObjectIndex</span>{
</span></span><span style=display:flex><span>    <span style=color:#ff636f>uint8_t</span> <span style=color:#58a1dd>sha1</span>[<span style=color:#a6be9d>20</span>];
</span></span><span style=display:flex><span>    <span style=color:#ff636f>uint32_t</span> <span style=color:#58a1dd>offset</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在使用 <code>std::vector</code> 之前，使用 <code>std::list</code> 存储对象，效率不高，在分析 FreeBSD 的 1G 多大的存储库时，在我的破笔记本上跑出了 9s 耗时，对象 300 多万。太慢了，而改成 vector 后，耗时为 3s。</p><p>最近，笔者决定优化一下，第一步是将比较函数的内联。最初的比较函数如下：</p><div class=highlight><pre tabindex=0 style=color:#1d2432;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ff636f>bool</span> <span style=color:#58a1dd>objectidxcompare</span>(<span style=color:#ff636f>const</span> <span style=color:#58a1dd>ObjectIndex</span> <span style=color:#ff636f>&amp;</span><span style=color:#58a1dd>first</span>, <span style=color:#ff636f>const</span> <span style=color:#58a1dd>ObjectIndex</span> <span style=color:#ff636f>&amp;</span><span style=color:#58a1dd>second</span>) {
</span></span><span style=display:flex><span>  <span style=color:#ff636f>return</span> (<span style=color:#58a1dd>first</span>.<span style=color:#58a1dd>offset</span> <span style=color:#ff636f>&gt;</span> <span style=color:#58a1dd>second</span>.<span style=color:#58a1dd>offset</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们知道，函数调用是需要耗费时间的，随着对象数目增多，这种影响愈加明显。于是我将 <code>ObjectIndex</code> 改造成如下：</p><div class=highlight><pre tabindex=0 style=color:#1d2432;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ff636f>struct</span> <span style=color:#58a1dd>ObjectIndex</span> {
</span></span><span style=display:flex><span>  <span style=color:#828b96;font-style:italic>/// DON&#39;t Modify
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic></span>  <span style=color:#ff636f>bool</span> <span style=color:#ff636f>operator</span><span style=color:#ff636f>&lt;</span>(<span style=color:#ff636f>const</span> <span style=color:#58a1dd>ObjectIndex</span> <span style=color:#ff636f>&amp;</span><span style=color:#58a1dd>o</span>) { <span style=color:#ff636f>return</span> <span style=color:#58a1dd>offset</span> <span style=color:#ff636f>&gt;</span> <span style=color:#58a1dd>o</span>.<span style=color:#58a1dd>offset</span>; }
</span></span><span style=display:flex><span>  <span style=color:#ff636f>uint8_t</span> <span style=color:#58a1dd>sha1</span>[<span style=color:#a6be9d>20</span>];
</span></span><span style=display:flex><span>  <span style=color:#ff636f>uint32_t</span> <span style=color:#58a1dd>offset</span>{<span style=color:#a6be9d>0</span>};
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>通过内联，运行时间减少了 13.8%。这还不够，std::sort 内部使用了 std::swap 交换对象，而 ObjectIndx::sha1 的交换需要拷贝，并且读取 sha1 值也是需要系统调用的。为什么不先不读取 sha1 值，而是保存 sha1 值的 index。ObjectIndex 格式改成如下：</p><div class=highlight><pre tabindex=0 style=color:#1d2432;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ff636f>struct</span> <span style=color:#58a1dd>ObjectIndex</span> {
</span></span><span style=display:flex><span>  <span style=color:#828b96;font-style:italic>/// DON&#39;t Modify
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic></span>  <span style=color:#ff636f>bool</span> <span style=color:#ff636f>operator</span><span style=color:#ff636f>&lt;</span>(<span style=color:#ff636f>const</span> <span style=color:#58a1dd>ObjectIndex</span> <span style=color:#ff636f>&amp;</span><span style=color:#58a1dd>o</span>) { <span style=color:#ff636f>return</span> <span style=color:#58a1dd>offset</span> <span style=color:#ff636f>&gt;</span> <span style=color:#58a1dd>o</span>.<span style=color:#58a1dd>offset</span>; }
</span></span><span style=display:flex><span>  <span style=color:#ff636f>uint32_t</span> <span style=color:#58a1dd>offset</span>{<span style=color:#a6be9d>0</span>};
</span></span><span style=display:flex><span>  <span style=color:#ff636f>uint32_t</span> <span style=color:#58a1dd>index</span>{<span style=color:#a6be9d>0</span>};
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>这样，我们不再读取 sha1 值，需要 sha1 值的时候，再通过偏移计算 sha1 在 idx 文件中的位置。</p><div class=highlight><pre tabindex=0 style=color:#1d2432;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#828b96;font-style:italic>#define GIT_SHA1_RAWSZ 20
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic></span><span style=color:#828b96;font-style:italic>// so buffer &gt;41,
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic></span><span style=color:#ff636f>char</span> <span style=color:#ff636f>*</span><span style=color:#58a1dd>sha1_to_hex_r</span>(<span style=color:#ff636f>char</span> <span style=color:#ff636f>*</span><span style=color:#58a1dd>buffer</span>, <span style=color:#ff636f>const</span> <span style=color:#ff636f>unsigned</span> <span style=color:#ff636f>char</span> <span style=color:#ff636f>*</span><span style=color:#58a1dd>sha1</span>) {
</span></span><span style=display:flex><span>  <span style=color:#ff636f>static</span> <span style=color:#ff636f>const</span> <span style=color:#ff636f>char</span> <span style=color:#58a1dd>hex</span>[] <span style=color:#ff636f>=</span> <span style=color:#a6be9d>&#34;0123456789abcdef&#34;</span>;
</span></span><span style=display:flex><span>  <span style=color:#ff636f>char</span> <span style=color:#ff636f>*</span><span style=color:#58a1dd>buf</span> <span style=color:#ff636f>=</span> <span style=color:#58a1dd>buffer</span>;
</span></span><span style=display:flex><span>  <span style=color:#ff636f>int</span> <span style=color:#58a1dd>i</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff636f>for</span> (<span style=color:#58a1dd>i</span> <span style=color:#ff636f>=</span> <span style=color:#a6be9d>0</span>; <span style=color:#58a1dd>i</span> <span style=color:#ff636f>&lt;</span> <span style=color:#58a1dd>GIT_SHA1_RAWSZ</span>; <span style=color:#58a1dd>i</span><span style=color:#ff636f>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#ff636f>unsigned</span> <span style=color:#ff636f>int</span> <span style=color:#58a1dd>val</span> <span style=color:#ff636f>=</span> <span style=color:#ff636f>*</span><span style=color:#58a1dd>sha1</span><span style=color:#ff636f>++</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff636f>*</span><span style=color:#58a1dd>buf</span><span style=color:#ff636f>++</span> <span style=color:#ff636f>=</span> <span style=color:#58a1dd>hex</span>[<span style=color:#58a1dd>val</span> <span style=color:#ff636f>&gt;&gt;</span> <span style=color:#a6be9d>4</span>];
</span></span><span style=display:flex><span>    <span style=color:#ff636f>*</span><span style=color:#58a1dd>buf</span><span style=color:#ff636f>++</span> <span style=color:#ff636f>=</span> <span style=color:#58a1dd>hex</span>[<span style=color:#58a1dd>val</span> <span style=color:#ff636f>&amp;</span> <span style=color:#a6be9d>0xf</span>];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#ff636f>*</span><span style=color:#58a1dd>buf</span> <span style=color:#ff636f>=</span> <span style=color:#a6be9d>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff636f>return</span> <span style=color:#58a1dd>buffer</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff636f>inline</span> <span style=color:#ff636f>const</span> <span style=color:#ff636f>char</span> <span style=color:#ff636f>*</span><span style=color:#58a1dd>Sha1FromIndex</span>(<span style=color:#58a1dd>FILE</span> <span style=color:#ff636f>*</span><span style=color:#58a1dd>fp</span>, <span style=color:#ff636f>char</span> <span style=color:#ff636f>*</span><span style=color:#58a1dd>buf</span>, <span style=color:#58a1dd>std</span><span style=color:#ff636f>::</span><span style=color:#ff636f>uint32_t</span> <span style=color:#58a1dd>i</span>) {
</span></span><span style=display:flex><span>  <span style=color:#ff636f>unsigned</span> <span style=color:#ff636f>char</span> <span style=color:#58a1dd>sha1__</span>[<span style=color:#a6be9d>20</span>];
</span></span><span style=display:flex><span>  <span style=color:#ff636f>constexpr</span> <span style=color:#ff636f>int</span> <span style=color:#58a1dd>offsetbegin</span> <span style=color:#ff636f>=</span> <span style=color:#a6be9d>4</span> <span style=color:#ff636f>+</span> <span style=color:#a6be9d>4</span> <span style=color:#ff636f>+</span> <span style=color:#a6be9d>4</span> <span style=color:#ff636f>+</span> <span style=color:#a6be9d>255</span> <span style=color:#ff636f>*</span> <span style=color:#a6be9d>4</span>;
</span></span><span style=display:flex><span>  <span style=color:#58a1dd>fseek</span>(<span style=color:#58a1dd>fp</span>, <span style=color:#58a1dd>offsetbegin</span> <span style=color:#ff636f>+</span> <span style=color:#58a1dd>i</span> <span style=color:#ff636f>*</span> <span style=color:#a6be9d>20</span>, <span style=color:#58a1dd>SEEK_SET</span>);
</span></span><span style=display:flex><span>  <span style=color:#ff636f>if</span> (<span style=color:#58a1dd>fread</span>(<span style=color:#58a1dd>sha1__</span>, <span style=color:#a6be9d>1</span>, <span style=color:#a6be9d>20</span>, <span style=color:#58a1dd>fp</span>) <span style=color:#ff636f>!=</span> <span style=color:#a6be9d>20</span>) {
</span></span><span style=display:flex><span>    <span style=color:#ff636f>return</span> <span style=color:#a6be9d>&#34;unkown&#34;</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#ff636f>::</span><span style=color:#58a1dd>sha1_to_hex_r</span>(<span style=color:#58a1dd>buf</span>, <span style=color:#58a1dd>sha1__</span>);
</span></span><span style=display:flex><span>  <span style=color:#ff636f>return</span> <span style=color:#58a1dd>buf</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样真的减少了一半的时间。比如 Linux 内核源码 1.9GB 数据，562 W 对象，从 1442 毫秒减少到 700 多毫秒。内存占用也减少了 2/3。不要小看 16Byte 字节的节省，几百万个对象节省的空间就很客观了。</p><h2 id=利用内存布局减少系统调用次数>利用内存布局减少系统调用次数</h2><p>就函数调用而言，要尽可能的减少频繁调用的函数的调用次数，特别是达到百万级别的，在读取偏移时就可以一次性读取，于是我将读取偏移改为一次性读写，利用 vector 预先分配的内存，核心代码如下：</p><div class=highlight><pre tabindex=0 style=color:#1d2432;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span> <span style=color:#58a1dd>std</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>vector</span><span style=color:#ff636f>&lt;</span><span style=color:#58a1dd>ObjectIndex</span><span style=color:#ff636f>&gt;</span> <span style=color:#58a1dd>objs</span>(<span style=color:#58a1dd>counts</span>);
</span></span><span style=display:flex><span>  <span style=color:#ff636f>auto</span> <span style=color:#58a1dd>objsraw</span> <span style=color:#ff636f>=</span> <span style=color:#58a1dd>objs</span>.<span style=color:#58a1dd>data</span>();
</span></span><span style=display:flex><span>  <span style=color:#ff636f>auto</span> <span style=color:#58a1dd>bufc</span> <span style=color:#ff636f>=</span> <span style=color:#ff636f>reinterpret_cast</span><span style=color:#ff636f>&lt;</span><span style=color:#ff636f>char</span> <span style=color:#ff636f>*&gt;</span>(<span style=color:#58a1dd>objsraw</span>);
</span></span><span style=display:flex><span>  <span style=color:#828b96;font-style:italic>/// 4*counts
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic></span>  <span style=color:#ff636f>auto</span> <span style=color:#58a1dd>binteger</span> <span style=color:#ff636f>=</span>
</span></span><span style=display:flex><span>      <span style=color:#ff636f>reinterpret_cast</span><span style=color:#ff636f>&lt;</span><span style=color:#ff636f>int</span> <span style=color:#ff636f>*&gt;</span>(<span style=color:#58a1dd>bufc</span> <span style=color:#ff636f>+</span> <span style=color:#ff636f>sizeof</span>(<span style=color:#58a1dd>ObjectIndex</span>) <span style=color:#ff636f>*</span> <span style=color:#58a1dd>counts</span> <span style=color:#ff636f>/</span> <span style=color:#a6be9d>2</span>);
</span></span><span style=display:flex><span>  <span style=color:#ff636f>if</span> (<span style=color:#58a1dd>fread</span>(<span style=color:#58a1dd>binteger</span>, <span style=color:#a6be9d>4</span>, <span style=color:#58a1dd>counts</span>, <span style=color:#58a1dd>fp</span>) <span style=color:#ff636f>!=</span> <span style=color:#58a1dd>counts</span>) {
</span></span><span style=display:flex><span>    <span style=color:#58a1dd>console</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>Printeln</span>(<span style=color:#a6be9d>&#34;fread error &#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#58a1dd>fclose</span>(<span style=color:#58a1dd>fp</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff636f>return</span> <span style=color:#58a1dd>false</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#ff636f>for</span> (<span style=color:#ff636f>uint32_t</span> <span style=color:#58a1dd>i</span> <span style=color:#ff636f>=</span> <span style=color:#a6be9d>0</span>; <span style=color:#58a1dd>i</span> <span style=color:#ff636f>&lt;</span> <span style=color:#58a1dd>counts</span>; <span style=color:#58a1dd>i</span><span style=color:#ff636f>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#828b96;font-style:italic>/// DON&#39;T  change the order of operations
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic></span>    <span style=color:#58a1dd>objsraw</span>[<span style=color:#58a1dd>i</span>].<span style=color:#58a1dd>offset</span> <span style=color:#ff636f>=</span> <span style=color:#58a1dd>ntohl</span>(<span style=color:#58a1dd>binteger</span>[<span style=color:#58a1dd>i</span>]);
</span></span><span style=display:flex><span>    <span style=color:#58a1dd>objsraw</span>[<span style=color:#58a1dd>i</span>].<span style=color:#58a1dd>index</span> <span style=color:#ff636f>=</span> <span style=color:#58a1dd>i</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#58a1dd>std</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>sort</span>(<span style=color:#58a1dd>objs</span>.<span style=color:#58a1dd>begin</span>(), <span style=color:#58a1dd>objs</span>.<span style=color:#58a1dd>end</span>());
</span></span></code></pre></div><p>这里一定要注意，index 的填充一定要后于偏移的计算。</p><p>这次优化比前面的 700 多毫秒减少了 100 多毫秒。</p><h2 id=更大的大文件检测>更大的大文件检测</h2><p>前面主要是针对 pack 文件小于 2GB的优化, 对于推送大于 2GB 的 pack 文件需要额外的处理，比如 offset 需要改成 <code>int64_t</code> 而且 offset 需要读取 8bytes 的条目。git 的文档并不详细，因此还需要从 git 源码中发现一些真实的解决方案。</p><div class=highlight><pre tabindex=0 style=color:#1d2432;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#828b96;font-style:italic>#define MEMSIZE_LIMIT (scale::Gigabyte * 4)
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic></span><span style=color:#828b96;font-style:italic>/// Please don&#39;t modify type layout.
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic></span><span style=color:#ff636f>template</span> <span style=color:#ff636f>&lt;</span><span style=color:#ff636f>typename</span> <span style=color:#58a1dd>IntegerT</span><span style=color:#ff636f>&gt;</span> <span style=color:#ff636f>struct</span> <span style=color:#58a1dd>object_base</span> {
</span></span><span style=display:flex><span>  <span style=color:#ff636f>bool</span> <span style=color:#ff636f>operator</span><span style=color:#ff636f>&lt;</span>(<span style=color:#ff636f>const</span> <span style=color:#58a1dd>object_base</span><span style=color:#ff636f>&lt;</span><span style=color:#58a1dd>IntegerT</span><span style=color:#ff636f>&gt;</span> <span style=color:#ff636f>&amp;</span><span style=color:#58a1dd>o</span>) { <span style=color:#ff636f>return</span> <span style=color:#58a1dd>offset</span> <span style=color:#ff636f>&gt;</span> <span style=color:#58a1dd>o</span>.<span style=color:#58a1dd>offset</span>; }
</span></span><span style=display:flex><span>  <span style=color:#58a1dd>IntegerT</span> <span style=color:#58a1dd>offset</span>{<span style=color:#a6be9d>0</span>};
</span></span><span style=display:flex><span>  <span style=color:#58a1dd>std</span><span style=color:#ff636f>::</span><span style=color:#ff636f>uint32_t</span> <span style=color:#58a1dd>index</span>{<span style=color:#a6be9d>0</span>};
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#ff636f>typedef</span> <span style=color:#58a1dd>object_base</span><span style=color:#ff636f>&lt;</span><span style=color:#58a1dd>std</span><span style=color:#ff636f>::</span><span style=color:#ff636f>uint32_t</span><span style=color:#ff636f>&gt;</span> <span style=color:#58a1dd>ObjectIndex</span>;
</span></span><span style=display:flex><span><span style=color:#ff636f>typedef</span> <span style=color:#58a1dd>object_base</span><span style=color:#ff636f>&lt;</span><span style=color:#58a1dd>std</span><span style=color:#ff636f>::</span><span style=color:#ff636f>uint64_t</span><span style=color:#ff636f>&gt;</span> <span style=color:#58a1dd>ObjectIndexLarge</span>;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#1d2432;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#828b96;font-style:italic>////
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic></span><span style=color:#ff636f>bool</span> <span style=color:#58a1dd>Gitidx</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>reviewlarge</span>(<span style=color:#58a1dd>std</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>size_t</span> <span style=color:#58a1dd>limitsize</span>, <span style=color:#58a1dd>std</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>size_t</span> <span style=color:#58a1dd>warnsize</span>) {
</span></span><span style=display:flex><span>  <span style=color:#ff636f>if</span> (<span style=color:#58a1dd>fseek</span>(<span style=color:#58a1dd>fp</span>, <span style=color:#a6be9d>4</span> <span style=color:#ff636f>+</span> <span style=color:#a6be9d>4</span> <span style=color:#ff636f>+</span> <span style=color:#58a1dd>nr</span> <span style=color:#ff636f>*</span> (<span style=color:#a6be9d>20</span> <span style=color:#ff636f>+</span> <span style=color:#a6be9d>4</span>) <span style=color:#ff636f>+</span> <span style=color:#a6be9d>256</span> <span style=color:#ff636f>*</span> <span style=color:#a6be9d>4</span>, <span style=color:#58a1dd>SEEK_SET</span>) <span style=color:#ff636f>!=</span> <span style=color:#a6be9d>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#58a1dd>console</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>Printeln</span>(<span style=color:#a6be9d>&#34;fseek error&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff636f>return</span> <span style=color:#58a1dd>false</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#ff636f>auto</span> <span style=color:#58a1dd>mmsize</span> <span style=color:#ff636f>=</span> <span style=color:#58a1dd>nr</span> <span style=color:#ff636f>*</span> <span style=color:#ff636f>sizeof</span>(<span style=color:#58a1dd>ObjectIndexLarge</span>) <span style=color:#ff636f>+</span> <span style=color:#ff636f>sizeof</span>(<span style=color:#58a1dd>std</span><span style=color:#ff636f>::</span><span style=color:#ff636f>uint64_t</span>) <span style=color:#ff636f>*</span> <span style=color:#58a1dd>lnr</span>;
</span></span><span style=display:flex><span>  <span style=color:#ff636f>if</span> (<span style=color:#58a1dd>mmsize</span> <span style=color:#ff636f>&gt;</span> <span style=color:#58a1dd>MEMSIZE_LIMIT</span>) {
</span></span><span style=display:flex><span>    <span style=color:#58a1dd>console</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>Printe</span>(<span style=color:#a6be9d>&#34;Idx file Too large. Unsupport it&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff636f>return</span> <span style=color:#58a1dd>false</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#58a1dd>std</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>vector</span><span style=color:#ff636f>&lt;</span><span style=color:#58a1dd>ObjectIndexLarge</span><span style=color:#ff636f>&gt;</span> <span style=color:#58a1dd>objs</span>(<span style=color:#58a1dd>nr</span>);
</span></span><span style=display:flex><span>  <span style=color:#ff636f>auto</span> <span style=color:#58a1dd>objsraw</span> <span style=color:#ff636f>=</span> <span style=color:#58a1dd>objs</span>.<span style=color:#58a1dd>data</span>();
</span></span><span style=display:flex><span>  <span style=color:#ff636f>auto</span> <span style=color:#58a1dd>bufc</span> <span style=color:#ff636f>=</span> <span style=color:#ff636f>reinterpret_cast</span><span style=color:#ff636f>&lt;</span><span style=color:#ff636f>char</span> <span style=color:#ff636f>*&gt;</span>(<span style=color:#58a1dd>objsraw</span>);
</span></span><span style=display:flex><span>  <span style=color:#828b96;font-style:italic>/// 4*counts
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic></span>  <span style=color:#ff636f>auto</span> <span style=color:#58a1dd>binteger</span> <span style=color:#ff636f>=</span> <span style=color:#ff636f>reinterpret_cast</span><span style=color:#ff636f>&lt;</span><span style=color:#58a1dd>std</span><span style=color:#ff636f>::</span><span style=color:#ff636f>uint32_t</span> <span style=color:#ff636f>*&gt;</span>(
</span></span><span style=display:flex><span>      <span style=color:#58a1dd>bufc</span> <span style=color:#ff636f>+</span> <span style=color:#ff636f>sizeof</span>(<span style=color:#58a1dd>ObjectIndexLarge</span>) <span style=color:#ff636f>*</span> <span style=color:#58a1dd>nr</span> <span style=color:#ff636f>-</span> <span style=color:#a6be9d>4</span> <span style=color:#ff636f>*</span> <span style=color:#58a1dd>nr</span>);
</span></span><span style=display:flex><span>  <span style=color:#ff636f>if</span> (<span style=color:#58a1dd>fread</span>(<span style=color:#58a1dd>binteger</span>, <span style=color:#a6be9d>1</span>, <span style=color:#a6be9d>4</span> <span style=color:#ff636f>*</span> <span style=color:#58a1dd>nr</span>, <span style=color:#58a1dd>fp</span>) <span style=color:#ff636f>!=</span> <span style=color:#a6be9d>4</span> <span style=color:#ff636f>*</span> <span style=color:#58a1dd>nr</span>) {
</span></span><span style=display:flex><span>    <span style=color:#58a1dd>console</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>Printeln</span>(<span style=color:#a6be9d>&#34;fread error &#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff636f>return</span> <span style=color:#58a1dd>false</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#58a1dd>std</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>vector</span><span style=color:#ff636f>&lt;</span><span style=color:#58a1dd>std</span><span style=color:#ff636f>::</span><span style=color:#ff636f>uint64_t</span><span style=color:#ff636f>&gt;</span> <span style=color:#58a1dd>lnrv</span>(<span style=color:#58a1dd>lnr</span>); <span style=color:#828b96;font-style:italic>//
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic></span>  <span style=color:#ff636f>if</span> (<span style=color:#58a1dd>fread</span>(<span style=color:#58a1dd>lnrv</span>.<span style=color:#58a1dd>data</span>(), <span style=color:#a6be9d>1</span>, <span style=color:#a6be9d>8</span> <span style=color:#ff636f>*</span> <span style=color:#58a1dd>lnr</span>, <span style=color:#58a1dd>fp</span>) <span style=color:#ff636f>!=</span> <span style=color:#a6be9d>8</span> <span style=color:#ff636f>*</span> <span style=color:#58a1dd>lnr</span>) {
</span></span><span style=display:flex><span>    <span style=color:#58a1dd>console</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>Printeln</span>(<span style=color:#a6be9d>&#34;fread 8byte error&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff636f>return</span> <span style=color:#58a1dd>false</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#828b96;font-style:italic>/// https://github.com/git/git/blob/master/builtin/index-pack.c#L1511
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic></span>  <span style=color:#ff636f>for</span> (<span style=color:#ff636f>uint32_t</span> <span style=color:#58a1dd>i</span> <span style=color:#ff636f>=</span> <span style=color:#a6be9d>0</span>; <span style=color:#58a1dd>i</span> <span style=color:#ff636f>&lt;</span> <span style=color:#58a1dd>nr</span>; <span style=color:#58a1dd>i</span><span style=color:#ff636f>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#828b96;font-style:italic>/// DON&#39;T  change the order of operations
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic></span>    <span style=color:#ff636f>auto</span> <span style=color:#58a1dd>off</span> <span style=color:#ff636f>=</span> <span style=color:#58a1dd>ntohl</span>(<span style=color:#58a1dd>binteger</span>[<span style=color:#58a1dd>i</span>]);
</span></span><span style=display:flex><span>    <span style=color:#ff636f>if</span> (<span style=color:#ff636f>!</span>(<span style=color:#58a1dd>off</span> <span style=color:#ff636f>&amp;</span> <span style=color:#a6be9d>0x80000000</span>)) {
</span></span><span style=display:flex><span>      <span style=color:#58a1dd>objsraw</span>[<span style=color:#58a1dd>i</span>].<span style=color:#58a1dd>offset</span> <span style=color:#ff636f>=</span> <span style=color:#58a1dd>off</span>;
</span></span><span style=display:flex><span>      <span style=color:#58a1dd>objsraw</span>[<span style=color:#58a1dd>i</span>].<span style=color:#58a1dd>index</span> <span style=color:#ff636f>=</span> <span style=color:#58a1dd>i</span>;
</span></span><span style=display:flex><span>      <span style=color:#ff636f>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#58a1dd>off</span> <span style=color:#ff636f>=</span> <span style=color:#58a1dd>off</span> <span style=color:#ff636f>&amp;</span> <span style=color:#a6be9d>0x7fffffff</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff636f>if</span> (<span style=color:#58a1dd>off</span> <span style=color:#ff636f>&gt;=</span> <span style=color:#58a1dd>lnr</span>) {
</span></span><span style=display:flex><span>      <span style=color:#58a1dd>console</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>Printeln</span>(<span style=color:#a6be9d>&#34;Bad Index data&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#ff636f>return</span> <span style=color:#58a1dd>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#58a1dd>objsraw</span>[<span style=color:#58a1dd>i</span>].<span style=color:#58a1dd>offset</span> <span style=color:#ff636f>=</span> <span style=color:#58a1dd>default_bswap64</span>(<span style=color:#58a1dd>lnrv</span>[<span style=color:#58a1dd>off</span>]);
</span></span><span style=display:flex><span>    <span style=color:#58a1dd>objsraw</span>[<span style=color:#58a1dd>i</span>].<span style=color:#58a1dd>index</span> <span style=color:#ff636f>=</span> <span style=color:#58a1dd>i</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#58a1dd>std</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>sort</span>(<span style=color:#58a1dd>objs</span>.<span style=color:#58a1dd>begin</span>(), <span style=color:#58a1dd>objs</span>.<span style=color:#58a1dd>end</span>());
</span></span><span style=display:flex><span>  <span style=color:#ff636f>uint64_t</span> <span style=color:#58a1dd>pre</span> <span style=color:#ff636f>=</span> <span style=color:#58a1dd>pksize</span> <span style=color:#ff636f>-</span> <span style=color:#a6be9d>20</span>;
</span></span><span style=display:flex><span>  <span style=color:#ff636f>for</span> (<span style=color:#ff636f>auto</span> <span style=color:#ff636f>&amp;</span><span style=color:#58a1dd>i</span> : <span style=color:#58a1dd>objs</span>) {
</span></span><span style=display:flex><span>    <span style=color:#ff636f>auto</span> <span style=color:#58a1dd>size</span> <span style=color:#ff636f>=</span> <span style=color:#58a1dd>pre</span> <span style=color:#ff636f>-</span> <span style=color:#58a1dd>i</span>.<span style=color:#58a1dd>offset</span>;
</span></span><span style=display:flex><span>    <span style=color:#58a1dd>pre</span> <span style=color:#ff636f>=</span> <span style=color:#58a1dd>i</span>.<span style=color:#58a1dd>offset</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff636f>if</span> (<span style=color:#58a1dd>size</span> <span style=color:#ff636f>&gt;=</span> <span style=color:#58a1dd>limitsize</span>) {
</span></span><span style=display:flex><span>      <span style=color:#ff636f>char</span> <span style=color:#58a1dd>buf</span>[<span style=color:#a6be9d>50</span>];
</span></span><span style=display:flex><span>      <span style=color:#58a1dd>console</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>Printeln</span>(<span style=color:#a6be9d>&#34;File: %s size %4.2f MB, more than %4.2f MB %ld&#34;</span>,
</span></span><span style=display:flex><span>                        <span style=color:#58a1dd>Sha1FromIndex</span>(<span style=color:#58a1dd>fp</span>, <span style=color:#58a1dd>buf</span>, <span style=color:#58a1dd>i</span>.<span style=color:#58a1dd>index</span>),
</span></span><span style=display:flex><span>                        (<span style=color:#ff636f>float</span>)<span style=color:#58a1dd>size</span> <span style=color:#ff636f>/</span> <span style=color:#58a1dd>scale</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>Megabyte</span>,
</span></span><span style=display:flex><span>                        (<span style=color:#ff636f>float</span>)<span style=color:#58a1dd>limitsize</span> <span style=color:#ff636f>/</span> <span style=color:#58a1dd>scale</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>Megabyte</span>, <span style=color:#58a1dd>i</span>.<span style=color:#58a1dd>offset</span>);
</span></span><span style=display:flex><span>      <span style=color:#828b96;font-style:italic>// bfilecount++;
</span></span></span><span style=display:flex><span><span style=color:#828b96;font-style:italic></span>      <span style=color:#ff636f>return</span> <span style=color:#58a1dd>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff636f>if</span> (<span style=color:#58a1dd>size</span> <span style=color:#ff636f>&gt;=</span> <span style=color:#58a1dd>warnsize</span>) {
</span></span><span style=display:flex><span>      <span style=color:#ff636f>if</span> (<span style=color:#58a1dd>wfs</span>.<span style=color:#58a1dd>size</span>() <span style=color:#ff636f>&lt;</span> <span style=color:#58a1dd>MaxNumberOfDetails</span>) {
</span></span><span style=display:flex><span>        <span style=color:#58a1dd>FileInfo</span> <span style=color:#58a1dd>fileinfo</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff636f>char</span> <span style=color:#58a1dd>buf</span>[<span style=color:#a6be9d>50</span>];
</span></span><span style=display:flex><span>        <span style=color:#58a1dd>fileinfo</span>.<span style=color:#58a1dd>path</span> <span style=color:#ff636f>=</span> <span style=color:#58a1dd>Sha1FromIndex</span>(<span style=color:#58a1dd>fp</span>, <span style=color:#58a1dd>buf</span>, <span style=color:#58a1dd>i</span>.<span style=color:#58a1dd>index</span>);
</span></span><span style=display:flex><span>        <span style=color:#58a1dd>fileinfo</span>.<span style=color:#58a1dd>size</span> <span style=color:#ff636f>=</span> <span style=color:#58a1dd>size</span>;
</span></span><span style=display:flex><span>        <span style=color:#58a1dd>wfs</span>.<span style=color:#58a1dd>push_back</span>(<span style=color:#58a1dd>std</span><span style=color:#ff636f>::</span><span style=color:#58a1dd>move</span>(<span style=color:#58a1dd>fileinfo</span>));
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#ff636f>return</span> <span style=color:#58a1dd>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=pack-文件格式限制>Pack 文件格式限制</h2><p>以上内容都是基于 Git Packfile 格式第二版。当 pack 文件内对象数目巨大时，以上优化需要大量内存，而在前面设置了最大内存限制，这意味着对象的数目是存在限制的，实际上需要的内存与 idx 文件的大小接近。在解析 pack 文件时常规的做法是使用 mmap ，但这不能很好的对偏移进行排序，从而达到快速检测的目的。本文也将更新一个 C++17 样例程序。</p><h2 id=检测何时引入大文件>检测何时引入大文件</h2><p>GitNativeHook 为了性能还是损失了一个功能，无法检测何时引入了大文件，大文件的文件名是什么，这个时候大家可以使用我开发的 git-analyze 工具去检测什么时候引入了大文件以及文件名：<a href=https://gitee.com/oscstudio/git-analyze>Git-Analyze</a></p><h2 id=最后>最后</h2><p>优化是无止尽的。如果大家有更好的方案可以与我讨论。</p><hr width=100% id=EOF><p style=color:#777>Last modified on 2017-11-22</p></div></div><nav class=post-pagination><a class=newer-posts href=/posts/2017/2017-11-27-asio-graceful-restart/>Next<br>基于 Asio 的服务器平滑重启方案
</a><a class=older-posts href=/posts/2017/2017-09-01-kisasum-hash-utility/>Previous<br>Kisasum Hash 实用工具</a></nav><div class=post-comment-wrapper></div></div></div></div></div><div id=sideContainer class=side-container><a class="a-block nav-head false" href=https://forcemz.net/><div class=nav-title>Charlie's Rethinking</div><div class=nav-subtitle>Themed by Diary.</div></a><div class=nav-link-list><a class="a-block nav-link-item active" href=/posts>归档
</a><a class="a-block nav-link-item false" href=/categories>分类
</a><a class="a-block nav-link-item false" href=/tags>标签
</a><a class="a-block nav-link-item false" href=/about>关于
</a><a class="a-block nav-link-item false" href=/index.xml>RSS Feed</a></div><div class=nav-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://risehere.net/>Rise</a><br>Ported from <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
Copyright (c) 2009-2024 J23</div></div><div id=extraContainer class=extra-container><div class=toc-wrapper><div class=toc><div class=toc-content><center>- CATALOG -</center><ul><ul><li><a href=#%e5%89%8d%e8%a8%80 class=nav-前言>前言</a></li><li><a href=#gitlab-%e7%9a%84-update-%e9%92%a9%e5%ad%90 class=nav-gitlab-的-update-钩子>Gitlab 的 Update 钩子</a></li><li><a href=#%e5%ae%8c%e5%85%a8%e6%a3%80%e6%b5%8b%e7%9a%84-git-%e5%8e%9f%e7%94%9f%e9%92%a9%e5%ad%90 class=nav-完全检测的-git-原生钩子>完全检测的 Git 原生钩子</a></li><li><a href=#%e5%8e%9f%e7%94%9f%e9%92%a9%e5%ad%90%e4%bd%bf%e7%94%a8%e7%8e%af%e5%a2%83%e9%9a%94%e7%a6%bb%e7%89%b9%e6%80%a7 class=nav-原生钩子使用环境隔离特性>原生钩子使用环境隔离特性</a></li><li><a href=#%e5%bb%b6%e6%97%b6%e8%af%bb%e7%9a%84%e5%8e%9f%e7%94%9f%e9%92%a9%e5%ad%90 class=nav-延时读的原生钩子>延时读的原生钩子</a></li><li><a href=#%e5%88%a9%e7%94%a8%e5%86%85%e5%ad%98%e5%b8%83%e5%b1%80%e5%87%8f%e5%b0%91%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e6%ac%a1%e6%95%b0 class=nav-利用内存布局减少系统调用次数>利用内存布局减少系统调用次数</a></li><li><a href=#%e6%9b%b4%e5%a4%a7%e7%9a%84%e5%a4%a7%e6%96%87%e4%bb%b6%e6%a3%80%e6%b5%8b class=nav-更大的大文件检测>更大的大文件检测</a></li><li><a href=#pack-%e6%96%87%e4%bb%b6%e6%a0%bc%e5%bc%8f%e9%99%90%e5%88%b6 class=nav-pack-文件格式限制>Pack 文件格式限制</a></li><li><a href=#%e6%a3%80%e6%b5%8b%e4%bd%95%e6%97%b6%e5%bc%95%e5%85%a5%e5%a4%a7%e6%96%87%e4%bb%b6 class=nav-检测何时引入大文件>检测何时引入大文件</a></li><li><a href=#%e6%9c%80%e5%90%8e class=nav-最后>最后</a></li></ul></div></div></div><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up
</i></a><a type=button class=pagination-action id=darkModeToggleButton><span class="material-icons pagination-action-icon" id=darkModeToggleIcon>dark_mode</span></a></div></div><div id=single-column-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://risehere.net/>Rise</a><br>Ported from <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
Copyright (c) 2009-2024 J23</div></div><script src=/js/journal.js></script></body></html>