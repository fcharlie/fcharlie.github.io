<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Windows on 江二十三的思考</title><link>https://forcemz.net/categories/windows/</link><description>Recent content in Windows on 江二十三的思考</description><generator>Hugo</generator><language>zh-CN</language><copyright>Copyright (c) 2009-2024 J23</copyright><lastBuildDate>Fri, 24 Apr 2020 10:00:00 +0800</lastBuildDate><atom:link href="https://forcemz.net/categories/windows/index.xml" rel="self" type="application/rss+xml"/><item><title>文件的真实路径</title><link>https://forcemz.net/posts/2020/2020-04-24-realpath/</link><pubDate>Fri, 24 Apr 2020 10:00:00 +0800</pubDate><guid>https://forcemz.net/posts/2020/2020-04-24-realpath/</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>最近浏览 Windows Terminal 提交，发现其文档中链接了一个 PowerShell 的 Issue：&lt;a href="https://github.com/PowerShell/PowerShell/issues/9970">Windows Store applications incorrectly assumed to be console applications &lt;/a>，这个问题描述起来很简单，就是在 PowerShell 中打开 &lt;code>wt.exe&lt;/code>， PowerShell 会一直等待 Windows Terminal 的退出，但实际上 Windows Terminal 是一个 GUI 程序，按照 Windows 的默认行为，PowerShell 在创建 Windows Terminal 进程后，就应该返回。这个问题是怎么产生的，其实很简单，&lt;code>wt.exe&lt;/code> 是 Windows Terminal 的 &lt;code>AppExecutionAlias&lt;/code>，&lt;code>AppExecutionAlias&lt;/code> 是一类特殊的重解析点，Windows 在创建进程时会根据 &lt;code>AppExecutionAlias&lt;/code> 设施的信息启动对应的 Store App。那么 PowerShell 应当获得相应 Store App 的主程序的 &lt;code>Subsystem&lt;/code> 才能正确的决定是否应该等待进程退出。因此这里获得其真实路径是必不可少的。&lt;/p></description></item><item><title>在 Windows 中实现 sudo</title><link>https://forcemz.net/posts/2019/2019-08-07-implement-sudo-in-windows/</link><pubDate>Wed, 07 Aug 2019 12:00:00 +0800</pubDate><guid>https://forcemz.net/posts/2019/2019-08-07-implement-sudo-in-windows/</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>&lt;em>这篇文章的想法来源于我在 &lt;a href="https://github.com/microsoft/terminal/issues/146">Windows Terminal Issue#146&lt;/a> 的&lt;a href="https://github.com/microsoft/terminal/issues/146#issuecomment-515812461">评论&lt;/a>。&lt;/em>&lt;/p>
&lt;p>&lt;a href="https://linux.die.net/man/8/sudo">sudo&lt;/a> 以另一个用户执行命令，通常是 &lt;code>root&lt;/code>。当普通用户需要以其他权限执行某项工作时，通常需要获得指定用户的权限，以目标权限 &lt;code>root&lt;/code> 为例，我们期望以 root 权限运行，可以使用 &lt;code>su&lt;/code> 登录到 &lt;code>root&lt;/code> 用户，在这种情况下，一直到退出 &lt;code>root&lt;/code>。都使用的是 &lt;code>root&lt;/code> 权限，这实际上并不是安全的，处于高级别权限的时间应当尽量的短。而使用 &lt;code>sudo&lt;/code> 获得 root 权限要安全的多，这种情况下，只有特定的命令才会获得 root 权限，而不是整个用户和 shell. 话又说回来，sudo 是如何获得 root 权限的？在 Windows 中的 sudo 又是怎么一回事，如何在 Windows 中实现类似的 sudo.&lt;/p></description></item><item><title>Windows 命令行转义杂谈</title><link>https://forcemz.net/posts/2019/2019-07-20-cmdline-escape/</link><pubDate>Sat, 20 Jul 2019 20:00:00 +0800</pubDate><guid>https://forcemz.net/posts/2019/2019-07-20-cmdline-escape/</guid><description>&lt;h2 id="背景">背景&lt;/h2>
&lt;p>2019 年五月的 Microsoft Build 大会，微软宣布了 Windows Terminal，并在 Github 上开源：&lt;a href="https://github.com/microsoft/terminal">https://github.com/microsoft/terminal&lt;/a>。我作为技术爱好者，肯定要尝鲜一番。&lt;/p>
&lt;p>使用截图：&lt;/p>
&lt;p>&lt;img src="https://user-images.githubusercontent.com/6904176/58634006-b05e6080-82d9-11e9-9e3f-2715647edf1b.png" alt="">&lt;/p>
&lt;p>在使用的过程中，多标签，亚克力的窗口背景和 &lt;code>Colour Emojis&lt;/code> 都让我非常满意，而且使用 Direct2D 绘制的 emoji，看起来要比 Mintty 使用 GDI+PNG 的 emoji 方案好的多（PNG 的 emoji 无论是放大和缩小都更容易失真，Mintty 并没有 Segoe UI 字体的 emoji 风格，其他风格我并不太喜欢）。不过我在使用的过程中发现了一个 BUG，即 &lt;a href="https://github.com/microsoft/terminal/issues/1090">Bug Report: The conhost command line is not properly escaped #1090 &lt;/a>，后来我又提交了一个 PR 修复了此问题，在研究其他软件源码时，我发现这个问题并不是个例，因此有必要对此问题进行一次讨论，便有了此文。&lt;/p></description></item><item><title>Privexec 杂谈</title><link>https://forcemz.net/posts/2018/2018-11-30-privexec-new/</link><pubDate>Fri, 30 Nov 2018 21:00:00 +0800</pubDate><guid>https://forcemz.net/posts/2018/2018-11-30-privexec-new/</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>本站的开篇就是讲的 &lt;a href="https://forcemz.net/container/2015/06/12/AppContainer/">《Windows AppContainer 降权，隔离与安全》&lt;/a>，一晃三年多过去了，这三年之中，我开发了一个 &lt;a href="https://github.com/M2Team/Privexec">Privexec&lt;/a>，一个以其他权限启动进程的工具，支持启动 &lt;code>AppContainer&lt;/code> 进程，前段实现有用户发起了功能请求&lt;sup>1&lt;/sup>，让 &lt;code>Privexec&lt;/code> 支持设置 &lt;code>AppContainer&lt;/code> 的 &lt;code>Capabilities&lt;/code>，而不是像以前一样在启动 &lt;code>AppContainer&lt;/code> 进程时使用 &lt;code>CreateWellKnownSid&lt;/code> 创建所有的与 &lt;code>AppContainer&lt;/code> 相关的 &lt;code>Capabilities SIDs&lt;/code>。于是乎，我就花了一点时间将 Privexec 重构了一番，有所感悟，便将其写下来。&lt;/p></description></item><item><title>Privexec 的内幕（一）标准输出原理与彩色输出实现</title><link>https://forcemz.net/posts/2017/2017-06-05-color-console/</link><pubDate>Mon, 05 Jun 2017 20:00:00 +0800</pubDate><guid>https://forcemz.net/posts/2017/2017-06-05-color-console/</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>&lt;a href="https://github.com/M2Team/Privexec">Privexec&lt;/a> 是笔者借鉴远景好友 MouriNaruto 的 &lt;a href="https://github.com/M2Team/NSudo">NSudo&lt;/a> 而开发的一个&lt;strong>提权或者降权&lt;/strong>执行进程的工具。其中 wsudo 是 Privexec 的命令行版本。&lt;/p>
&lt;p>在 wsudo 中，笔者使用了 Privexec.Console 提供彩色输出，截图如下：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/M2Team/Privexec/master/docs/images/wsudo.png" alt="wsudo">&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/M2Team/Privexec/master/docs/images/wsudo3.png" alt="wsudo3">&lt;/p>
&lt;p>本文将讲述标准输出是如何输出到控制台的，以及怎样在 Windows 中实现同时支持标准控制台和 MSYS2 Cygwin 终端模拟器以及 VT 模式的控制台彩色输出。&lt;/p></description></item><item><title>Windows 下载功能的实现 - C++ 篇</title><link>https://forcemz.net/posts/2016/2016-11-03-win32-download-feature/</link><pubDate>Thu, 03 Nov 2016 20:00:00 +0800</pubDate><guid>https://forcemz.net/posts/2016/2016-11-03-win32-download-feature/</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>笔者计划开发一个自用的包管理工具，需要支持下载功能，笔者尝试了多种 Windows 下载 API，这里分享出来。&lt;/p>
&lt;h2 id="urldownloadtofile">URLDownloadToFile&lt;/h2>
&lt;p>自 Internet Explorer 3.0 开始，Urlmon.dll 中开始提供 URLDownloadToFile，支持从远程服务器上下载文件到本地。
URLDownloadToFile 会先将文件下载到 IE 缓存目录，然后再复制到设置的输出目录，如果第二次下载，就省去了下载时间。
Urlmon 还提供了下载到缓存目录的函数 URLDownloadToCacheFile，正因为 URLDownloadToFile 先下载到缓存目录，
就会出现缓存问题，可以使用 Wininet 中的 DeleteUrlCacheEntry 删除缓存。&lt;/p></description></item><item><title>Windows 10 原生 SSH 功能探索</title><link>https://forcemz.net/posts/2016/2016-06-04-windows-ssh-server/</link><pubDate>Sat, 04 Jun 2016 20:00:00 +0800</pubDate><guid>https://forcemz.net/posts/2016/2016-06-04-windows-ssh-server/</guid><description>&lt;h1 id="windows-10-原生-ssh-功能探索">Windows 10 原生 SSH 功能探索&lt;/h1>
&lt;p>在 Windows 10 Insider 14352 中，增加了两个服务 SshBrokerGroup SshProxyGroup，
通过命令&lt;/p>
&lt;p>&lt;code>netstat -aon |findstr &amp;quot;22&amp;quot;&lt;/code>&lt;/p>
&lt;p>即可找到 端口 22 绑定的进程也就是 SshProxyGroup 服务进程，而 22 端口是 SSH 服务器监听的端口，
在 Windows 目录 &lt;em>C:\Windows\System32&lt;/em> 可以发现 几个与 SSH 相关的 dll 和 exe：&lt;/p></description></item></channel></rss>